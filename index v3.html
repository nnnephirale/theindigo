<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarot Reader</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --background: 0 0% 100%;
            --foreground: 240 10% 3.9%;
            --card: 0 0% 100%;
            --card-foreground: 240 10% 3.9%;
            --primary: 240 5.9% 10%;
            --primary-foreground: 0 0% 98%;
            --muted: 240 4.8% 95.9%;
            --muted-foreground: 240 3.8% 46.1%;
            --accent: 240 4.8% 95.9%;
            --border: 240 5.9% 90%;
            --radius: 0.5rem;
            /* Responsive card sizes */
            --deck-card-width: clamp(40px, 5vw, 60px);
            --deck-card-height: calc(var(--deck-card-width) * 1.6);
            --placed-card-width: clamp(100px, 12vw, 150px);
            --placed-card-height: calc(var(--placed-card-width) * 1.6);
            --card-overlap: clamp(6px, 0.8vw, 10px);
        }
        .dark {
            --background: 240 10% 3.9%;
            --foreground: 0 0% 98%;
            --card: 240 10% 3.9%;
            --card-foreground: 0 0% 98%;
            --primary: 0 0% 98%;
            --primary-foreground: 240 5.9% 10%;
            --muted: 240 3.7% 15.9%;
            --muted-foreground: 240 5% 64.9%;
            --accent: 240 3.7% 15.9%;
            --border: 240 3.7% 15.9%;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            min-height: 100vh;
            overflow: hidden;
            transition: background-color 0.2s, color 0.2s;
            user-select: none;
            -webkit-user-select: none;
        }
        .app-container { display: flex; flex-direction: column; height: 100vh; }
        header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid hsl(var(--border));
        }
        h1 { font-weight: 600; font-size: 0.9rem; letter-spacing: -0.01em; }
        .header-left { display: flex; align-items: center; gap: 1rem; }
        .controls { display: flex; gap: 0.5rem; align-items: center; }
        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.375rem;
            font-size: 0.8125rem; font-weight: 500; font-family: inherit;
            height: 2rem; padding: 0 0.875rem; border-radius: var(--radius);
            transition: all 0.15s ease; cursor: pointer;
        }
        .btn-default { background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border: none; }
        .btn-default:hover { opacity: 0.9; }
        .btn-outline { background: transparent; border: 1px solid hsl(var(--border)); color: hsl(var(--foreground)); }
        .btn-outline:hover { background: hsl(var(--accent)); }
        .btn-outline.active { background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border-color: hsl(var(--primary)); }
        .btn-ghost { background: transparent; border: none; color: hsl(var(--foreground)); padding: 0 0.5rem; }
        .btn-ghost:hover { background: hsl(var(--accent)); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .toggle-group { display: flex; align-items: center; gap: 0.5rem; }
        .toggle-group.compact { gap: 0.375rem; }
        .toggle-group.compact .toggle-label { font-size: 0.75rem; }
        .toggle-label { font-size: 0.8125rem; color: hsl(var(--muted-foreground)); }
        .toggle {
            position: relative; width: 2.25rem; height: 1.25rem;
            background: hsl(var(--muted)); border-radius: 9999px;
            cursor: pointer; transition: background 0.2s;
        }
        .toggle::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 1rem; height: 1rem; background: white;
            border-radius: 50%; transition: transform 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .toggle.active { background: hsl(var(--primary)); }
        .toggle.active::after { transform: translateX(1rem); }
        main { 
            flex: 1; display: flex; flex-direction: column; padding: 1rem; gap: 0.75rem; overflow: hidden;
            position: relative;
        }
        .reading-surface {
            flex: 1;
            background: hsl(var(--muted) / 0.5);
            position: relative; overflow: hidden;
            min-height: 200px;
            border-radius: var(--radius) var(--radius) 0 0;
        }
        .reading-surface::before {
            content: '';
            position: absolute;
            inset: 0;
            border: 1px solid hsl(var(--border));
            border-bottom: none;
            border-radius: var(--radius) var(--radius) 0 0;
            pointer-events: none;
            z-index: 6;
            mask-image: linear-gradient(to bottom, 
                black 0%, 
                black calc(100% - 120px),
                transparent 100%
            );
            -webkit-mask-image: linear-gradient(to bottom, 
                black 0%, 
                black calc(100% - 120px),
                transparent 100%
            );
        }
        .reading-surface::after {
            content: '';
            position: absolute;
            bottom: 0; left: 0; right: 0;
            height: 120px;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                hsl(var(--background)) 100%
            );
            pointer-events: none;
            z-index: 5;
        }
        .reading-surface-content {
            position: absolute; inset: 0;
            transform-origin: center center;
            transition: transform 0.15s ease;
        }
        .reading-surface-content::before {
            content: 'Drag cards here'; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 0.875rem;
            color: hsl(var(--muted-foreground) / 0.6); pointer-events: none;
            transition: opacity 0.3s;
        }
        .reading-surface.has-cards .reading-surface-content::before { opacity: 0; }
        .deck-controls {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
        }
        
        /* Surface Tools (Aa, Zoom) */
        .surface-tools {
            position: absolute; top: 0.5rem; right: 0.5rem; z-index: 100;
            display: flex; flex-direction: column; gap: 0.25rem;
        }
        .text-tool-btn, .zoom-btn {
            padding: 0 0.5rem; height: 1.75rem; font-weight: 600;
            width: 2.25rem; justify-content: center;
        }
        .text-tool-btn.active { background: hsl(var(--primary)); color: hsl(var(--primary-foreground)); border-color: hsl(var(--primary)); }
        .text-tool-label { font-size: 0.8125rem; }
        .zoom-btn .icon { width: 0.875rem; height: 0.875rem; }
        
        /* Text Mode Cursors */
        .reading-surface.text-mode { cursor: text; }
        .reading-surface.text-mode-drawing { cursor: crosshair; }
        
        /* Text Box */
        .text-box {
            position: absolute; z-index: 55;
            min-width: 20px; min-height: 1.5em;
        }
        .text-box.show-border {
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--card) / 0.5);
        }
        .text-box.editing .text-box-border,
        .text-box:hover .text-box-border {
            opacity: 1;
        }
        .text-box-border {
            position: absolute; inset: -1px;
            border: 1px solid hsl(var(--primary) / 0.5);
            border-radius: var(--radius);
            pointer-events: none; opacity: 0;
            transition: opacity 0.15s;
        }
        .text-box.show-border .text-box-border {
            border-color: hsl(var(--border));
            opacity: 1;
        }
        .text-box-content {
            width: 100%; height: auto;
            border: none; background: transparent;
            font-family: inherit; font-size: 0.8125rem; line-height: 1.5;
            color: hsl(var(--foreground)); resize: none;
            padding: 0; outline: none;
            overflow: hidden;
        }
        .text-box-content::placeholder { color: hsl(var(--muted-foreground) / 0.4); }
        
        /* Drag Zone - padding area around textarea */
        .text-box { padding: 8px; cursor: move; }
        .text-box-content { cursor: text; }
        .text-box.dragging { opacity: 0.8; cursor: grabbing; }
        .text-box.dragging * { cursor: grabbing; }
        
        /* Resize Handles */
        .text-box-handle {
            position: absolute; width: 8px; height: 8px;
            background: hsl(var(--card));
            border: 1.5px solid hsl(var(--foreground) / 0.5);
            border-radius: 1px; opacity: 0;
            transition: opacity 0.15s;
        }
        .text-box.editing .text-box-handle,
        .text-box:hover .text-box-handle { opacity: 1; }
        .text-box-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .text-box-handle.n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .text-box-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .text-box-handle.e { top: 50%; right: -4px; transform: translateY(-50%); cursor: e-resize; }
        .text-box-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }
        .text-box-handle.s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .text-box-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .text-box-handle.w { top: 50%; left: -4px; transform: translateY(-50%); cursor: w-resize; }
        
        /* Text Box Controls (font size) */
        .text-box-controls {
            position: absolute; right: 100%; top: 0; margin-right: 0.5rem;
            display: flex; flex-direction: column; align-items: center;
            background: hsl(var(--card)); border: 1px solid hsl(var(--border));
            border-radius: var(--radius); padding: 0.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            opacity: 0; pointer-events: none;
            transition: opacity 0.15s;
        }
        .text-box.editing .text-box-controls {
            opacity: 1; pointer-events: auto;
        }
        .text-box.editing.dragging .text-box-controls {
            opacity: 0; pointer-events: none;
        }
        .text-box-font-btn {
            background: none; border: none; cursor: pointer;
            color: hsl(var(--muted-foreground)); padding: 0.25rem 0.5rem;
            font-size: 0.875rem; font-weight: 500; border-radius: 2px;
            transition: all 0.15s; line-height: 1;
        }
        .text-box-font-btn:hover { background: hsl(var(--accent)); color: hsl(var(--foreground)); }
        .text-box-font-label {
            font-size: 0.75rem; font-weight: 600; color: hsl(var(--foreground));
            padding: 0.125rem 0;
        }
        .placed-card { 
            position: absolute; cursor: pointer; 
            width: var(--placed-card-width) !important; 
            height: var(--placed-card-height) !important;
            animation: cardGrow 0.5s cubic-bezier(0.34, 1.2, 0.64, 1) forwards;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            transform-style: preserve-3d;
            transform: translate(-50%, -50%);
        }
        @keyframes cardGrow {
            0% { transform: translate(-50%, -50%) scale(0.3) translateY(20px); opacity: 0; }
            60% { opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1) translateY(0); opacity: 1; }
        }
        @keyframes cardFlip {
            0% { transform: translate(-50%, -50%) rotateY(0deg) translateY(0) scale(1); }
            30% { transform: translate(-50%, -50%) rotateY(0deg) translateY(-30px) scale(1.05); box-shadow: 0 20px 40px rgba(0,0,0,0.2); }
            50% { transform: translate(-50%, -50%) rotateY(90deg) translateY(-30px) scale(1.05); }
            100% { transform: translate(-50%, -50%) rotateY(180deg) translateY(0) scale(1); }
        }
        @keyframes cardFlipReversed {
            0% { transform: translate(-50%, -50%) rotateY(0deg) translateY(0) scale(1); }
            30% { transform: translate(-50%, -50%) rotateY(0deg) translateY(-30px) scale(1.05); box-shadow: 0 20px 40px rgba(0,0,0,0.2); }
            50% { transform: translate(-50%, -50%) rotateY(90deg) translateY(-30px) scale(1.05); }
            100% { transform: translate(-50%, -50%) rotateY(180deg) rotate(180deg) translateY(0) scale(1); }
        }
        .placed-card.flipping {
            animation: cardFlip 0.6s ease-out forwards;
            z-index: 100;
        }
        .placed-card.flipping.will-reverse {
            animation: cardFlipReversed 0.6s ease-out forwards;
        }
        .placed-card:hover:not(.flipped):not(.flipping) { transform: translate(-50%, -50%) scale(1.02); z-index: 100; }
        .placed-card.flipped { 
            transform: translate(-50%, -50%) rotateY(180deg) !important; 
            animation: none;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        .placed-card.flipped.reversed { 
            transform: translate(-50%, -50%) rotateY(180deg) rotate(180deg) !important; 
        }
        .placed-card.flipped.lifting {
            transform: translate(-50%, -50%) rotateY(180deg) scale(1.08) translateY(-8px) !important;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.3), 0 6px 12px rgba(0, 0, 0, 0.2);
            z-index: 200;
        }
        .placed-card.flipped.reversed.lifting {
            transform: translate(-50%, -50%) rotateY(180deg) rotate(180deg) scale(1.08) translateY(-8px) !important;
        }
        .placed-card .card-face { border-radius: var(--radius); }
        .placed-card .card-placeholder .card-number { font-size: 2rem; font-weight: 600; }
        .placed-card .card-placeholder .card-suit { font-size: 0.875rem; }
        .modal-card.reversed { transform: rotate(180deg); }
        .keywords-upright.active .keywords-label { font-weight: 700; }
        .keywords-reversed.active .keywords-label { font-weight: 700; }
        .keywords-upright:not(.active), .keywords-reversed:not(.active) { opacity: 0.5; }
        .deck-area {
            position: relative; 
            border-radius: var(--radius);
            height: 78px;
            flex-shrink: 0;
            overflow: visible;
            z-index: 10;
        }
        .deck-container { 
            position: absolute; 
            bottom: 0; left: 0; right: 0;
            height: clamp(100px, 15vh, 160px);
            display: flex; align-items: center; justify-content: center; 
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            transform: translateY(0);
            transition: transform 0.25s ease, clip-path 0.25s ease;
            clip-path: inset(0 0 0 0);
        }
        .deck-area.docked .deck-container {
            transform: translateY(calc(100% - 78px));
            clip-path: inset(0 0 calc(100% - 78px) 0);
        }
        .deck-area.docked:hover .deck-container,
        .deck-area.docked.dragging-active .deck-container {
            transform: translateY(0);
            clip-path: inset(0 0 0 0);
        }
        @media (max-width: 600px) {
            .deck-container { height: clamp(140px, 22vh, 200px); }
            .deck-area.docked .deck-container { 
                transform: translateY(calc(100% - 78px)); 
                clip-path: inset(0 0 calc(100% - 78px) 0);
            }
            .deck-area { height: 78px; }
        }
        .card {
            width: var(--deck-card-width); height: var(--deck-card-height); position: absolute; cursor: grab;
            transform-style: preserve-3d; transition: transform 0.3s ease;
        }
        .card:active { cursor: grabbing; }
        .deck-container .card {
            transition: transform 0.15s ease-out;
        }
        .deck-container:not(.dragging-active) .card:hover:not(.dragging) {
            transform: translate(-50%, calc(-50% - 15px)) translateX(var(--base-x, 0px)) translateY(var(--base-y, 0px)) rotate(var(--base-rot, 0deg)) scale(1.05) !important;
        }
        
        /* Mobile Arc Selection Mode */
        .deck-container.arc-selection-active .card {
            transition: transform 0.15s ease-out, opacity 0.15s ease-out, box-shadow 0.15s ease-out;
        }
        .deck-container.arc-selection-active .card.arc-centered {
            transform: translate(-50%, calc(-50% - 25px)) translateX(var(--base-x, 0px)) translateY(var(--base-y, 0px)) rotate(var(--base-rot, 0deg)) scale(1.1) !important;
            z-index: 100 !important;
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.3), 0 0 12px rgba(255, 255, 255, 0.08);
        }
        .deck-container.arc-selection-active .card:not(.arc-centered) {
            opacity: 0.6;
            filter: brightness(0.85);
        }
        
        /* Card ready to place - staged above deck */
        .deck-container .card.card-staged {
            transform: translate(-50%, calc(-50% - 60px)) translateX(0px) scale(1.15) !important;
            z-index: 200 !important;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35), 0 0 20px rgba(255, 255, 255, 0.1);
            animation: cardStagedFloat 2s ease-in-out infinite;
        }
        @keyframes cardStagedFloat {
            0%, 100% { transform: translate(-50%, calc(-50% - 60px)) translateX(0px) scale(1.15); }
            50% { transform: translate(-50%, calc(-50% - 66px)) translateX(0px) scale(1.17); }
        }
        
        .card.dragging {
            transition: none !important;
            z-index: 10000 !important;
            pointer-events: none;
        }
        .card-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden; -webkit-backface-visibility: hidden;
            border-radius: calc(var(--radius) - 2px);
            box-shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.04);
        }
        .card-back {
            background: url('https://steve-p.org/cards/small/sm_RWSa-X-RL.webp') center/cover;
            display: flex;
            align-items: center; justify-content: center;
            border: 1px solid hsl(var(--border));
            z-index: 2;
        }
        .card-front {
            background: hsl(var(--card)); transform: rotateY(180deg);
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; padding: 0.25rem; overflow: hidden;
            border: 1px solid hsl(var(--border));
        }
        .card-front img { width: 100%; height: 100%; object-fit: cover; border-radius: 2px; }
        .card-placeholder {
            width: 100%; height: 100%; display: flex; flex-direction: column;
            align-items: center; justify-content: center; text-align: center; gap: 0.125rem;
        }
        .card-placeholder .card-number { font-size: 1rem; font-weight: 600; color: hsl(var(--foreground)); }
        .card-placeholder .card-suit { font-size: 0.625rem; color: hsl(var(--muted-foreground)); text-transform: uppercase; letter-spacing: 0.02em; }
        .card.flipped { transform: rotateY(180deg); }
        .dev-label {
            position: absolute; bottom: -14px; left: 50%; transform: translateX(-50%);
            font-size: 0.5rem; font-family: ui-monospace, monospace;
            color: hsl(var(--muted-foreground)); white-space: nowrap;
            background: hsl(var(--background)); padding: 1px 3px; border-radius: 2px;
            opacity: 0; transition: opacity 0.15s ease; border: 1px solid hsl(var(--border));
        }
        body.dev-mode .dev-label { opacity: 1; }
        .card.shuffling { transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .card.settling { transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        .card-modal {
            position: fixed; inset: 0; 
            background: hsl(var(--background) / 0.85);
            backdrop-filter: blur(12px); 
            display: flex; align-items: center;
            justify-content: center; z-index: 1000; 
            opacity: 0; visibility: hidden;
            transition: opacity 0.2s ease, visibility 0s 0.2s;
            padding: 1rem;
        }
        .card-modal.active { 
            opacity: 1; visibility: visible; 
            transition: opacity 0.2s ease, visibility 0s 0s;
        }
        .modal-content {
            background: hsl(var(--card)); border: 1px solid hsl(var(--border));
            border-radius: var(--radius); padding: 2.5rem; text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1); max-width: 520px; width: 95%;
            max-height: 90vh; overflow-y: auto;
            user-select: text;
            -webkit-user-select: text;
        }
        .modal-position-title {
            margin-bottom: 1rem; text-align: center;
        }
        .modal-position-title .position-name {
            font-size: 0.75rem; font-weight: 600; text-transform: uppercase;
            letter-spacing: 0.05em; color: hsl(var(--primary));
            background: hsl(var(--primary) / 0.1); padding: 0.375rem 1rem;
            border-radius: 9999px; display: inline-block;
        }
        .modal-position-title .position-prompt {
            display: block; margin-top: 0.5rem;
            font-size: 0.875rem; font-style: italic;
            color: hsl(var(--muted-foreground)); line-height: 1.4;
        }
        .modal-card {
            width: 220px; height: 352px; margin: 0 auto 1.5rem; border-radius: var(--radius);
            overflow: hidden; background: hsl(var(--muted)); display: flex;
            align-items: center; justify-content: center; border: 1px solid hsl(var(--border));
        }
        .modal-card img { width: 100%; height: 100%; object-fit: cover; }
        .modal-placeholder { text-align: center; padding: 1.5rem; }
        .modal-placeholder .card-number { font-size: 3.5rem; font-weight: 600; margin-bottom: 0.5rem; }
        .modal-placeholder .card-suit { font-size: 1rem; color: hsl(var(--muted-foreground)); text-transform: uppercase; letter-spacing: 0.05em; }
        .modal-title { font-weight: 600; font-size: 1.5rem; margin-bottom: 0.25rem; }
        .modal-subtitle { font-size: 1rem; color: hsl(var(--muted-foreground)); margin-bottom: 1.25rem; }
        .modal-meanings { text-align: left; }
        .meanings-toggle {
            width: 100%; display: flex; align-items: center; justify-content: space-between;
            padding: 0.625rem 0.75rem; background: hsl(var(--muted) / 0.5); border: none;
            border-radius: calc(var(--radius) - 2px); cursor: pointer; font-size: 0.8125rem;
            font-weight: 500; color: hsl(var(--foreground)); transition: background 0.15s;
        }
        .meanings-toggle:hover { background: hsl(var(--muted)); }
        .meanings-toggle .chevron { width: 1rem; height: 1rem; transition: transform 0.2s; }
        .meanings-toggle.expanded .chevron { transform: rotate(180deg); }
        .meanings-content {
            display: none; padding-top: 0.75rem;
        }
        .meanings-content.expanded { display: block; }
        .keywords-section { display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem; padding: 0.75rem; background: hsl(var(--muted) / 0.5); border-radius: calc(var(--radius) - 2px); }
        .keywords-upright, .keywords-reversed { display: flex; align-items: flex-start; gap: 0.5rem; }
        .keywords-label { font-size: 0.625rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: hsl(var(--muted-foreground)); min-width: 52px; padding-top: 0.125rem; }
        .keywords-upright .keywords-label { color: hsl(142 76% 36%); }
        .keywords-reversed .keywords-label { color: hsl(0 72% 51%); }
        .keywords-list { font-size: 0.8125rem; color: hsl(var(--foreground)); line-height: 1.4; }
        .meaning-text { font-size: 0.875rem; line-height: 1.6; color: hsl(var(--foreground) / 0.85); }
        .modal-close {
            position: absolute; top: 1rem; right: 1rem; width: 2rem; height: 2rem;
            display: flex; align-items: center; justify-content: center;
            background: hsl(var(--card)); border: 1px solid hsl(var(--border));
            border-radius: var(--radius); color: hsl(var(--foreground));
            font-size: 1.25rem; cursor: pointer; transition: background 0.15s;
        }
        .modal-close:hover { background: hsl(var(--accent)); }
        .dev-panel {
            position: fixed; bottom: 0; left: 0; right: 0; background: hsl(var(--card));
            border-top: 1px solid hsl(var(--border)); padding: 0.875rem 1rem;
            transform: translateY(100%); transition: transform 0.2s ease;
            max-height: 22vh; overflow-y: auto; z-index: 500;
        }
        body.dev-mode .dev-panel { transform: translateY(0); }
        .dev-panel h3 { font-size: 0.6875rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; color: hsl(var(--muted-foreground)); margin-bottom: 0.5rem; }
        .dev-info { display: flex; flex-wrap: wrap; gap: 0.25rem; font-size: 0.5625rem; font-family: ui-monospace, monospace; }
        .dev-info span { background: hsl(var(--muted)); padding: 2px 5px; border-radius: 2px; }
        .dev-info span.duplicate { background: hsl(0 84% 60% / 0.15); color: hsl(0 84% 50%); }
        .validation-status { margin-top: 0.5rem; padding: 0.375rem 0.625rem; border-radius: var(--radius); font-size: 0.6875rem; font-family: ui-monospace, monospace; }
        .validation-status.valid { background: hsl(142 76% 36% / 0.1); color: hsl(142 70% 35%); }
        .validation-status.invalid { background: hsl(0 84% 60% / 0.1); color: hsl(0 84% 50%); }
        .instructions { text-align: center; font-size: 0.75rem; color: hsl(var(--muted-foreground) / 0.7); pointer-events: none; padding: 0.5rem 0; }
        .icon { width: 1rem; height: 1rem; }
        
        /* Save Modal */
        .save-modal {
            position: fixed; inset: 0; background: hsl(var(--background) / 0.8);
            backdrop-filter: blur(4px); display: flex; align-items: center;
            justify-content: center; z-index: 1100; opacity: 0; visibility: hidden;
            transition: all 0.2s ease;
        }
        .save-modal.active { opacity: 1; visibility: visible; }
        .save-modal-content {
            background: hsl(var(--card)); border: 1px solid hsl(var(--border));
            border-radius: var(--radius); padding: 1.5rem; width: 90%; max-width: 320px;
            transform: scale(0.95); transition: transform 0.2s ease;
        }
        .save-modal.active .save-modal-content { transform: scale(1); }
        .save-modal-content h3 { font-size: 1rem; font-weight: 600; margin-bottom: 1rem; }
        .save-modal-content input {
            width: 100%; padding: 0.5rem 0.75rem; border: 1px solid hsl(var(--border));
            border-radius: var(--radius); font-size: 0.875rem; font-family: inherit;
            background: hsl(var(--background)); color: hsl(var(--foreground));
            margin-bottom: 1rem;
        }
        .save-modal-content input:focus { outline: none; border-color: hsl(var(--primary)); }
        .save-modal-buttons { display: flex; gap: 0.5rem; justify-content: flex-end; flex-wrap: wrap; }
        .save-existing-info {
            background: hsl(var(--muted) / 0.5); padding: 0.75rem;
            border-radius: var(--radius); margin-bottom: 1rem; display: none;
        }
        .save-existing-info.show { display: block; }
        .save-existing-label { font-size: 0.75rem; color: hsl(var(--muted-foreground)); margin: 0 0 0.25rem 0; }
        .save-existing-title { font-size: 0.875rem; font-weight: 500; margin: 0 0 0.125rem 0; }
        .save-existing-date { font-size: 0.75rem; color: hsl(var(--muted-foreground)); margin: 0; }
        #saveNewBtn { display: none; }
        .save-modal.has-existing #saveNewBtn { display: inline-flex; }
        .save-modal.has-existing #saveConfirmBtn::after { content: ' (Overwrite)'; }
        
        /* History Panel */
        .history-overlay {
            position: fixed; inset: 0; background: hsl(var(--background) / 0.5);
            backdrop-filter: blur(2px); z-index: 1000; opacity: 0; visibility: hidden;
            transition: all 0.2s ease;
        }
        .history-overlay.active { opacity: 1; visibility: visible; }
        .history-panel {
            position: fixed; top: 0; right: 0; bottom: 0; width: 90%; max-width: 360px;
            background: hsl(var(--card)); border-left: 1px solid hsl(var(--border));
            z-index: 1001; transform: translateX(100%); transition: transform 0.3s ease;
            display: flex; flex-direction: column;
        }
        .history-panel.active { transform: translateX(0); }
        .history-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 1rem; border-bottom: 1px solid hsl(var(--border));
        }
        .history-header h3 { font-size: 1rem; font-weight: 600; margin: 0; }
        .history-close { padding: 0.25rem; }
        .history-list {
            flex: 1; overflow-y: auto; padding: 0.5rem;
        }
        .history-item {
            padding: 0.75rem; border: 1px solid hsl(var(--border)); border-radius: var(--radius);
            margin-bottom: 0.5rem; cursor: pointer; transition: all 0.15s;
        }
        .history-item:hover { background: hsl(var(--muted) / 0.5); }
        .history-item-title { font-weight: 500; font-size: 0.875rem; margin-bottom: 0.25rem; }
        .history-item-meta { font-size: 0.75rem; color: hsl(var(--muted-foreground)); display: flex; justify-content: space-between; align-items: center; }
        .history-item-cards { display: flex; gap: 0.25rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .history-item-card {
            width: 24px; height: 38px; background: hsl(var(--muted));
            border-radius: 2px; border: 1px solid hsl(var(--border));
            display: flex; align-items: center; justify-content: center;
            font-size: 0.5rem; font-weight: 600; overflow: hidden;
        }
        .history-item-card.reversed { transform: rotate(180deg); }
        .history-item-card img { width: 100%; height: 100%; object-fit: cover; }
        .history-item-delete {
            background: none; border: none; color: hsl(var(--muted-foreground));
            cursor: pointer; padding: 0.25rem; border-radius: var(--radius);
            opacity: 0; transition: all 0.15s;
        }
        .history-item:hover .history-item-delete { opacity: 1; }
        .history-item-delete:hover { color: hsl(0 84% 50%); background: hsl(0 84% 50% / 0.1); }
        .history-empty {
            flex: 1; display: flex; align-items: center; justify-content: center;
            color: hsl(var(--muted-foreground)); font-size: 0.875rem;
        }
        .history-empty.hidden { display: none; }
        .history-footer {
            padding: 0.75rem 1rem; border-top: 1px solid hsl(var(--border));
        }
        .btn-danger { color: hsl(0 84% 50%); }
        .btn-danger:hover { background: hsl(0 84% 50% / 0.1); }
        
        /* Toast */
        .toast {
            position: fixed; bottom: 1.5rem; left: 50%; transform: translateX(-50%) translateY(1rem);
            background: hsl(var(--primary)); color: hsl(var(--primary-foreground));
            padding: 0.625rem 1rem; border-radius: var(--radius); font-size: 0.875rem;
            opacity: 0; transition: all 0.3s ease; z-index: 2000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        
        /* Spread Panel */
        .spread-overlay {
            position: fixed; inset: 0; background: hsl(var(--background) / 0.5);
            backdrop-filter: blur(2px); z-index: 1000; opacity: 0; visibility: hidden;
            transition: all 0.2s ease;
        }
        .spread-overlay.active { opacity: 1; visibility: visible; }
        .spread-panel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
            background: hsl(var(--card)); border: 1px solid hsl(var(--border));
            border-radius: var(--radius); z-index: 1001; width: 90%; max-width: 500px;
            max-height: 80vh; display: flex; flex-direction: column;
            opacity: 0; visibility: hidden; transition: all 0.2s ease;
        }
        .spread-panel.active { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); }
        .spread-panel-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 1rem 1.25rem; border-bottom: 1px solid hsl(var(--border));
        }
        .spread-panel-header h3 { font-size: 1rem; font-weight: 600; margin: 0; }
        .spread-panel-close { padding: 0.25rem; }
        .spread-list { flex: 1; overflow-y: auto; padding: 0.75rem; }
        .spread-item {
            padding: 0.875rem; border: 1px solid hsl(var(--border)); border-radius: var(--radius);
            margin-bottom: 0.5rem; cursor: pointer; transition: all 0.15s;
        }
        .spread-item:hover { background: hsl(var(--muted) / 0.5); border-color: hsl(var(--primary) / 0.5); }
        .spread-item.active { background: hsl(var(--primary) / 0.1); border-color: hsl(var(--primary)); }
        .spread-item-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.375rem; }
        .spread-item-name { font-weight: 500; font-size: 0.9375rem; }
        .spread-item-count { font-size: 0.75rem; color: hsl(var(--muted-foreground)); background: hsl(var(--muted)); padding: 0.125rem 0.5rem; border-radius: 9999px; }
        .spread-item-desc { font-size: 0.8125rem; color: hsl(var(--muted-foreground)); line-height: 1.4; }
        .spread-item-preview { display: flex; gap: 0.25rem; margin-top: 0.5rem; justify-content: center; }
        .spread-preview-slot { width: 16px; height: 24px; border: 1px solid hsl(var(--border)); border-radius: 2px; background: hsl(var(--muted) / 0.3); }
        .spread-panel-footer { padding: 0.75rem 1.25rem; border-top: 1px solid hsl(var(--border)); }
        
        /* Spread Slots on Reading Surface */
        .spread-slot {
            position: absolute; transform: translate(-50%, -50%);
            border: 1px solid hsl(var(--border)); border-radius: var(--radius);
            background: hsl(var(--muted) / 0.4);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            pointer-events: none;
            width: var(--placed-card-width);
            height: var(--placed-card-height);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
            z-index: 10;
        }
        .spread-slot.highlight {
            border-color: hsl(var(--primary)); 
            background: hsl(var(--primary) / 0.15);
            box-shadow: 0 0 0 2px hsl(var(--primary) / 0.3);
        }
        .spread-slot-label {
            position: absolute; top: -1.5rem; left: 50%; transform: translateX(-50%);
            font-size: 0.625rem; color: hsl(var(--foreground)); font-weight: 500;
            white-space: nowrap; text-align: center;
            z-index: 200;
            background: hsl(var(--card)); 
            border: 1px solid hsl(var(--border));
            padding: 0.1875rem 0.5rem;
            border-radius: 9999px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            cursor: help;
            pointer-events: auto;
        }
        .spread-slot.filled { 
            background: transparent; 
            border-color: transparent;
            box-shadow: none;
        }
        
        /* Spread Reference Panel */
        .spread-reference {
            position: absolute; top: 0.5rem; left: 0.5rem;
            width: 160px; min-width: 120px; max-width: 300px;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border)); border-radius: var(--radius);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100; overflow: hidden;
            display: none; resize: both;
        }
        .spread-reference.active { display: block; }
        .spread-reference-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 0.375rem 0.5rem; background: hsl(var(--muted) / 0.5);
            border-bottom: 1px solid hsl(var(--border));
            cursor: move;
        }
        .spread-reference-title {
            font-size: 0.625rem; font-weight: 600; color: hsl(var(--foreground));
            text-transform: uppercase; letter-spacing: 0.025em;
        }
        .spread-reference-close {
            width: 1rem; height: 1rem; border-radius: 50%;
            background: hsl(var(--muted)); border: none; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            color: hsl(var(--muted-foreground)); font-size: 0.625rem; line-height: 1;
        }
        .spread-reference-close:hover { background: hsl(var(--destructive) / 0.2); color: hsl(var(--destructive)); }
        .spread-reference-content {
            padding: 0.5rem; aspect-ratio: 1; position: relative;
            background: hsl(var(--background)); min-height: 100px;
        }
        .spread-ref-card {
            position: absolute; transform: translate(-50%, -50%);
            width: 20px; height: 32px;
            background: hsl(var(--card)); border: 1px solid hsl(var(--border));
            border-radius: 2px; display: flex; align-items: center; justify-content: center;
            font-size: 0.625rem; font-weight: 600; color: hsl(var(--foreground));
        }
        .spread-ref-card.filled {
            background: hsl(var(--primary)); color: hsl(var(--primary-foreground));
            border-color: hsl(var(--primary));
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <div class="header-left">
                <h1>Tarot Reader</h1>
                <div class="toggle-group">
                    <span class="toggle-label">Dev</span>
                    <div class="toggle" id="devToggle"></div>
                </div>
            </div>
            <div class="controls">
                <button class="btn btn-outline" id="saveBtn" title="Save Reading">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
                    </svg>
                    <span>Save Reading</span>
                </button>
                <button class="btn btn-outline" id="historyBtn" title="Reading History">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>Reading History</span>
                </button>
                <button class="btn btn-ghost" id="themeToggle" title="Toggle theme">
                    <svg class="icon" id="themeIcon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                    </svg>
                </button>
            </div>
        </header>
        <main>
            <div class="reading-surface" id="readingSurface">
                <div class="surface-tools">
                    <button class="btn btn-outline text-tool-btn" id="textToolBtn" title="Text Tool (Aa)">
                        <span class="text-tool-label">Aa</span>
                    </button>
                    <button class="btn btn-outline zoom-btn" id="zoomInBtn" title="Zoom In">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6" />
                        </svg>
                    </button>
                    <button class="btn btn-outline zoom-btn" id="zoomOutBtn" title="Zoom Out">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M18 12H6" />
                        </svg>
                    </button>
                </div>
                <div class="spread-reference" id="spreadReference">
                    <div class="spread-reference-header" id="spreadRefHeader">
                        <span class="spread-reference-title" id="spreadRefTitle">Spread</span>
                        <button class="spread-reference-close" id="spreadRefClose">×</button>
                    </div>
                    <div class="spread-reference-content" id="spreadRefContent">
                        <!-- Populated by JS -->
                    </div>
                </div>
                <div class="reading-surface-content" id="readingSurfaceContent"></div>
            </div>
            <div class="deck-area">
                <div class="deck-container" id="deckContainer"></div>
            </div>
            <div class="deck-controls">
                <button class="btn btn-outline" id="shuffleBtn" title="Shuffle">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3 17h2.735a4 4 0 003.43-1.94l3.67-6.12A4 4 0 0116.265 7H21m0 0l-3-3m3 3l-3 3M3 7h2.735a4 4 0 013.43 1.94l.5.83m6.07 4.29l.5.83A4 4 0 0016.265 17H21m0 0l-3-3m3 3l-3 3" />
                    </svg>
                </button>
                <button class="btn btn-outline" id="resetBtn" title="Return Cards">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" />
                    </svg>
                </button>
                <button class="btn btn-outline toggle-btn" id="reversalsToggle" title="Reversals">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4" />
                    </svg>
                    <span>Reversals</span>
                </button>
                <button class="btn btn-outline" id="spreadBtn" title="Pick a Spread">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                        <rect x="2" y="3" width="5" height="8" rx="1" />
                        <rect x="9.5" y="3" width="5" height="8" rx="1" />
                        <rect x="17" y="3" width="5" height="8" rx="1" />
                        <rect x="5.75" y="13" width="5" height="8" rx="1" />
                        <rect x="13.25" y="13" width="5" height="8" rx="1" />
                    </svg>
                    <span>Pick a Spread</span>
                </button>
            </div>
            <p class="instructions">Drag cards to the reading surface · Click to reveal</p>
        </main>
    </div>
    <div class="card-modal" id="cardModal">
        <button class="modal-close" id="modalClose">×</button>
        <div class="modal-content">
            <div class="modal-position-title" id="modalPositionTitle" style="display: none;"></div>
            <div class="modal-card" id="modalCard"></div>
            <h2 class="modal-title" id="modalTitle"></h2>
            <p class="modal-subtitle" id="modalSubtitle"></p>
            <div class="modal-meanings" id="modalMeanings">
                <button class="meanings-toggle" id="meaningsToggle">
                    <span>Meanings</span>
                    <svg class="chevron" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                    </svg>
                </button>
                <div class="meanings-content" id="meaningsContent">
                    <div class="keywords-section">
                        <div class="keywords-upright">
                            <span class="keywords-label">Upright</span>
                            <span class="keywords-list" id="keywordsUpright"></span>
                        </div>
                        <div class="keywords-reversed">
                            <span class="keywords-label">Reversed</span>
                            <span class="keywords-list" id="keywordsReversed"></span>
                        </div>
                    </div>
                    <div class="meaning-text" id="meaningText"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="dev-panel">
        <h3>Deck Validation</h3>
        <div class="dev-info" id="devInfo"></div>
        <div class="validation-status" id="validationStatus"></div>
    </div>
    
    <!-- Save Modal -->
    <div class="save-modal" id="saveModal">
        <div class="save-modal-content">
            <h3>Save Reading</h3>
            <div class="save-existing-info" id="saveExistingInfo">
                <p class="save-existing-label">This reading was previously saved as:</p>
                <p class="save-existing-title" id="saveExistingTitle"></p>
                <p class="save-existing-date" id="saveExistingDate"></p>
            </div>
            <input type="text" id="readingTitleInput" placeholder="Enter a title (optional)" maxlength="100">
            <div class="save-modal-buttons">
                <button class="btn btn-outline" id="saveCancelBtn">Cancel</button>
                <button class="btn btn-outline" id="saveNewBtn">Save as New</button>
                <button class="btn btn-default" id="saveConfirmBtn">Save</button>
            </div>
        </div>
    </div>
    
    <!-- History Panel -->
    <div class="history-panel" id="historyPanel">
        <div class="history-header">
            <h3>Reading History</h3>
            <button class="btn btn-ghost history-close" id="historyClose">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <div class="history-list" id="historyList">
            <!-- Populated by JS -->
        </div>
        <div class="history-empty" id="historyEmpty">
            <p>No saved readings yet</p>
        </div>
        <div class="history-footer">
            <button class="btn btn-ghost btn-danger" id="clearHistoryBtn">Clear All History</button>
        </div>
    </div>
    <div class="history-overlay" id="historyOverlay"></div>
    
    <!-- Spread Panel -->
    <div class="spread-panel" id="spreadPanel">
        <div class="spread-panel-header">
            <h3>Pick a Spread</h3>
            <button class="btn btn-ghost spread-panel-close" id="spreadPanelClose">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <div class="spread-list" id="spreadList">
            <!-- Populated by JS -->
        </div>
        <div class="spread-panel-footer">
            <button class="btn btn-outline" id="clearSpreadBtn">Clear Spread</button>
        </div>
    </div>
    <div class="spread-overlay" id="spreadOverlay"></div>
    
</body>
<script>
// ============================================
// IMAGE CONFIGURATION
// ============================================
const USE_IMAGES = true;

function getCardImageUrl(card) {
    const baseUrl = 'https://steve-p.org/cards/small/sm_RWSa-';
    
    if (card.arcana === 'Major') {
        // Major Arcana: T-00 to T-21
        return `${baseUrl}T-${card.number.toString().padStart(2, '0')}.webp`;
    }
    
    // Minor Arcana suit codes
    const suitCode = { Wands: 'W', Cups: 'C', Swords: 'S', Pentacles: 'P' }[card.suit];
    
    // Number/court mapping
    let numCode;
    if (card.number === 1) {
        numCode = '0A'; // Ace
    } else if (card.number <= 10) {
        numCode = card.number.toString().padStart(2, '0');
    } else if (card.number === 11) {
        numCode = 'J1'; // Page
    } else if (card.number === 12) {
        numCode = 'J2'; // Knight
    } else if (card.number === 13) {
        numCode = 'QU'; // Queen
    } else if (card.number === 14) {
        numCode = 'KI'; // King
    }
    
    return `${baseUrl}${suitCode}-${numCode}.webp`;
}

// Full 78-card Rider-Waite deck
const TAROT_DECK = [
    // Major Arcana (22)
    { id: 'major-00', name: 'The Fool', arcana: 'Major', number: 0 },
    { id: 'major-01', name: 'The Magician', arcana: 'Major', number: 1 },
    { id: 'major-02', name: 'The High Priestess', arcana: 'Major', number: 2 },
    { id: 'major-03', name: 'The Empress', arcana: 'Major', number: 3 },
    { id: 'major-04', name: 'The Emperor', arcana: 'Major', number: 4 },
    { id: 'major-05', name: 'The Hierophant', arcana: 'Major', number: 5 },
    { id: 'major-06', name: 'The Lovers', arcana: 'Major', number: 6 },
    { id: 'major-07', name: 'The Chariot', arcana: 'Major', number: 7 },
    { id: 'major-08', name: 'Strength', arcana: 'Major', number: 8 },
    { id: 'major-09', name: 'The Hermit', arcana: 'Major', number: 9 },
    { id: 'major-10', name: 'Wheel of Fortune', arcana: 'Major', number: 10 },
    { id: 'major-11', name: 'Justice', arcana: 'Major', number: 11 },
    { id: 'major-12', name: 'The Hanged Man', arcana: 'Major', number: 12 },
    { id: 'major-13', name: 'Death', arcana: 'Major', number: 13 },
    { id: 'major-14', name: 'Temperance', arcana: 'Major', number: 14 },
    { id: 'major-15', name: 'The Devil', arcana: 'Major', number: 15 },
    { id: 'major-16', name: 'The Tower', arcana: 'Major', number: 16 },
    { id: 'major-17', name: 'The Star', arcana: 'Major', number: 17 },
    { id: 'major-18', name: 'The Moon', arcana: 'Major', number: 18 },
    { id: 'major-19', name: 'The Sun', arcana: 'Major', number: 19 },
    { id: 'major-20', name: 'Judgement', arcana: 'Major', number: 20 },
    { id: 'major-21', name: 'The World', arcana: 'Major', number: 21 },
    // Wands (14)
    { id: 'wands-01', name: 'Ace of Wands', arcana: 'Minor', suit: 'Wands', number: 1 },
    { id: 'wands-02', name: 'Two of Wands', arcana: 'Minor', suit: 'Wands', number: 2 },
    { id: 'wands-03', name: 'Three of Wands', arcana: 'Minor', suit: 'Wands', number: 3 },
    { id: 'wands-04', name: 'Four of Wands', arcana: 'Minor', suit: 'Wands', number: 4 },
    { id: 'wands-05', name: 'Five of Wands', arcana: 'Minor', suit: 'Wands', number: 5 },
    { id: 'wands-06', name: 'Six of Wands', arcana: 'Minor', suit: 'Wands', number: 6 },
    { id: 'wands-07', name: 'Seven of Wands', arcana: 'Minor', suit: 'Wands', number: 7 },
    { id: 'wands-08', name: 'Eight of Wands', arcana: 'Minor', suit: 'Wands', number: 8 },
    { id: 'wands-09', name: 'Nine of Wands', arcana: 'Minor', suit: 'Wands', number: 9 },
    { id: 'wands-10', name: 'Ten of Wands', arcana: 'Minor', suit: 'Wands', number: 10 },
    { id: 'wands-11', name: 'Page of Wands', arcana: 'Minor', suit: 'Wands', number: 11 },
    { id: 'wands-12', name: 'Knight of Wands', arcana: 'Minor', suit: 'Wands', number: 12 },
    { id: 'wands-13', name: 'Queen of Wands', arcana: 'Minor', suit: 'Wands', number: 13 },
    { id: 'wands-14', name: 'King of Wands', arcana: 'Minor', suit: 'Wands', number: 14 },
    // Cups (14)
    { id: 'cups-01', name: 'Ace of Cups', arcana: 'Minor', suit: 'Cups', number: 1 },
    { id: 'cups-02', name: 'Two of Cups', arcana: 'Minor', suit: 'Cups', number: 2 },
    { id: 'cups-03', name: 'Three of Cups', arcana: 'Minor', suit: 'Cups', number: 3 },
    { id: 'cups-04', name: 'Four of Cups', arcana: 'Minor', suit: 'Cups', number: 4 },
    { id: 'cups-05', name: 'Five of Cups', arcana: 'Minor', suit: 'Cups', number: 5 },
    { id: 'cups-06', name: 'Six of Cups', arcana: 'Minor', suit: 'Cups', number: 6 },
    { id: 'cups-07', name: 'Seven of Cups', arcana: 'Minor', suit: 'Cups', number: 7 },
    { id: 'cups-08', name: 'Eight of Cups', arcana: 'Minor', suit: 'Cups', number: 8 },
    { id: 'cups-09', name: 'Nine of Cups', arcana: 'Minor', suit: 'Cups', number: 9 },
    { id: 'cups-10', name: 'Ten of Cups', arcana: 'Minor', suit: 'Cups', number: 10 },
    { id: 'cups-11', name: 'Page of Cups', arcana: 'Minor', suit: 'Cups', number: 11 },
    { id: 'cups-12', name: 'Knight of Cups', arcana: 'Minor', suit: 'Cups', number: 12 },
    { id: 'cups-13', name: 'Queen of Cups', arcana: 'Minor', suit: 'Cups', number: 13 },
    { id: 'cups-14', name: 'King of Cups', arcana: 'Minor', suit: 'Cups', number: 14 },
    // Swords (14)
    { id: 'swords-01', name: 'Ace of Swords', arcana: 'Minor', suit: 'Swords', number: 1 },
    { id: 'swords-02', name: 'Two of Swords', arcana: 'Minor', suit: 'Swords', number: 2 },
    { id: 'swords-03', name: 'Three of Swords', arcana: 'Minor', suit: 'Swords', number: 3 },
    { id: 'swords-04', name: 'Four of Swords', arcana: 'Minor', suit: 'Swords', number: 4 },
    { id: 'swords-05', name: 'Five of Swords', arcana: 'Minor', suit: 'Swords', number: 5 },
    { id: 'swords-06', name: 'Six of Swords', arcana: 'Minor', suit: 'Swords', number: 6 },
    { id: 'swords-07', name: 'Seven of Swords', arcana: 'Minor', suit: 'Swords', number: 7 },
    { id: 'swords-08', name: 'Eight of Swords', arcana: 'Minor', suit: 'Swords', number: 8 },
    { id: 'swords-09', name: 'Nine of Swords', arcana: 'Minor', suit: 'Swords', number: 9 },
    { id: 'swords-10', name: 'Ten of Swords', arcana: 'Minor', suit: 'Swords', number: 10 },
    { id: 'swords-11', name: 'Page of Swords', arcana: 'Minor', suit: 'Swords', number: 11 },
    { id: 'swords-12', name: 'Knight of Swords', arcana: 'Minor', suit: 'Swords', number: 12 },
    { id: 'swords-13', name: 'Queen of Swords', arcana: 'Minor', suit: 'Swords', number: 13 },
    { id: 'swords-14', name: 'King of Swords', arcana: 'Minor', suit: 'Swords', number: 14 },
    // Pentacles (14)
    { id: 'pentacles-01', name: 'Ace of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 1 },
    { id: 'pentacles-02', name: 'Two of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 2 },
    { id: 'pentacles-03', name: 'Three of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 3 },
    { id: 'pentacles-04', name: 'Four of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 4 },
    { id: 'pentacles-05', name: 'Five of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 5 },
    { id: 'pentacles-06', name: 'Six of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 6 },
    { id: 'pentacles-07', name: 'Seven of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 7 },
    { id: 'pentacles-08', name: 'Eight of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 8 },
    { id: 'pentacles-09', name: 'Nine of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 9 },
    { id: 'pentacles-10', name: 'Ten of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 10 },
    { id: 'pentacles-11', name: 'Page of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 11 },
    { id: 'pentacles-12', name: 'Knight of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 12 },
    { id: 'pentacles-13', name: 'Queen of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 13 },
    { id: 'pentacles-14', name: 'King of Pentacles', arcana: 'Minor', suit: 'Pentacles', number: 14 },
];

// Card meanings data (source: Labyrinthos.co)
const TAROT_MEANINGS = {
    "major-00": {
        keywords: { upright: ["innocence", "new beginnings", "free spirit", "adventure"], reversed: ["recklessness", "taken advantage of", "inconsideration", "naivety"] },
        upright: "A beginning of a new journey filled with optimism and freedom. Every day is a chance to open up new areas in your life with anticipation, wonder, and curiosity.",
        reversed: "Acting without considering repercussions. Living in the moment without planning for the future. Be more aware so as not to be taken advantage of."
    },
    "major-01": {
        keywords: { upright: ["willpower", "desire", "creation", "manifestation"], reversed: ["trickery", "illusions", "out of touch", "manipulation"] },
        upright: "Making things manifest through skill, creativity, and determination. The power to turn ideas into action by utilizing your talents and inner resources.",
        reversed: "Untapped talents or using skills for deceptive purposes. Manipulation or illusions may be at work."
    },
    "major-02": {
        keywords: { upright: ["intuition", "unconscious", "inner voice", "mystery"], reversed: ["lack of center", "lost inner voice", "repressed feelings"] },
        upright: "Trust your intuition and inner voice. A time for introspection, meditation, and listening to your subconscious.",
        reversed: "Disconnection from intuition, ignoring your inner voice, or secrets being kept. Time to reconnect with your spiritual self."
    },
    "major-03": {
        keywords: { upright: ["motherhood", "fertility", "nature", "abundance"], reversed: ["dependence", "smothering", "emptiness", "creative block"] },
        upright: "Abundance, fertility, and nurturing energy. A time of creativity, growth, and connection with nature.",
        reversed: "Creative blocks, dependence on others, or feeling disconnected from your nurturing side."
    },
    "major-04": {
        keywords: { upright: ["authority", "structure", "control", "stability"], reversed: ["tyranny", "rigidity", "coldness", "domination"] },
        upright: "Authority, structure, and solid foundations. Leadership and the ability to achieve goals through organization.",
        reversed: "Excessive control, domination, or lack of discipline. May indicate an abuse of authority."
    },
    "major-05": {
        keywords: { upright: ["tradition", "conformity", "morality", "spiritual wisdom"], reversed: ["rebellion", "subversiveness", "new approaches"] },
        upright: "Seeking spiritual wisdom through conventional means. Education, mentorship, and following established paths.",
        reversed: "Challenging traditions or seeking unconventional spiritual paths. Time for new approaches."
    },
    "major-06": {
        keywords: { upright: ["partnerships", "duality", "union", "choices"], reversed: ["loss of balance", "one-sidedness", "disharmony"] },
        upright: "Union, partnership, and important choices. Alignment of values and harmony in relationships.",
        reversed: "Disharmony, imbalance in relationships, or facing a difficult choice."
    },
    "major-07": {
        keywords: { upright: ["direction", "control", "willpower", "victory"], reversed: ["lack of control", "lack of direction", "aggression"] },
        upright: "Victory through willpower and determination. Control over opposing forces and achievement of goals.",
        reversed: "Lack of direction, feeling out of control, or aggression without purpose."
    },
    "major-08": {
        keywords: { upright: ["inner strength", "bravery", "compassion", "courage"], reversed: ["self doubt", "weakness", "insecurity"] },
        upright: "Inner strength and patience. Mastery over base instincts through compassion rather than force.",
        reversed: "Self-doubt, weakness, or lack of confidence. Difficulty controlling emotions."
    },
    "major-09": {
        keywords: { upright: ["contemplation", "search for truth", "inner guidance"], reversed: ["loneliness", "isolation", "lost your way"] },
        upright: "Soul-searching, introspection, and seeking inner guidance. A time for solitude and reflection.",
        reversed: "Excessive isolation or losing your way. Fear of introspection."
    },
    "major-10": {
        keywords: { upright: ["change", "cycles", "inevitable fate", "turning point"], reversed: ["no control", "clinging to control", "bad luck"] },
        upright: "A turning point and the cyclical nature of life. Destiny and karma at work. Embrace coming changes.",
        reversed: "Resistance to change or feeling like you have no control. This too shall pass."
    },
    "major-11": {
        keywords: { upright: ["cause and effect", "clarity", "truth", "fairness"], reversed: ["dishonesty", "unaccountability", "unfairness"] },
        upright: "Truth, fairness, and the law of cause and effect. Accountability and consequences of actions.",
        reversed: "Injustice, dishonesty, or lack of accountability."
    },
    "major-12": {
        keywords: { upright: ["sacrifice", "release", "martyrdom", "new perspective"], reversed: ["stalling", "needless sacrifice", "fear of sacrifice"] },
        upright: "Suspension, sacrifice, and letting go. Seeing things from a new perspective.",
        reversed: "Stalling, resistance to necessary sacrifice, or fear of letting go."
    },
    "major-13": {
        keywords: { upright: ["end of cycle", "beginnings", "change", "transformation"], reversed: ["fear of change", "holding on", "stagnation"] },
        upright: "Endings and beginnings, transformation and transition. The end of one cycle and start of another.",
        reversed: "Resistance to change or holding onto what no longer serves you."
    },
    "major-14": {
        keywords: { upright: ["middle path", "patience", "finding meaning", "balance"], reversed: ["extremes", "excess", "lack of balance"] },
        upright: "Balance, moderation, and patience. Finding the middle path and mixing elements in harmony.",
        reversed: "Imbalance, excess, or going to extremes."
    },
    "major-15": {
        keywords: { upright: ["addiction", "materialism", "playfulness", "shadow self"], reversed: ["freedom", "release", "restoring control"] },
        upright: "Bondage to material things or shadow aspects of self. Can also represent playfulness.",
        reversed: "Breaking free from bondage or reclaiming control over your life."
    },
    "major-16": {
        keywords: { upright: ["sudden upheaval", "broken pride", "disaster", "revelation"], reversed: ["disaster avoided", "delayed disaster", "fear of suffering"] },
        upright: "Sudden change and the destruction of false beliefs. A necessary breakdown before breakthrough.",
        reversed: "Avoiding disaster or internal transformation rather than external chaos."
    },
    "major-17": {
        keywords: { upright: ["hope", "faith", "rejuvenation", "serenity"], reversed: ["faithlessness", "discouragement", "insecurity"] },
        upright: "Hope, faith, and renewal after difficulty. Inspiration and connection to the divine.",
        reversed: "Loss of faith, discouragement, or feeling disconnected from hope."
    },
    "major-18": {
        keywords: { upright: ["unconscious", "illusions", "intuition", "dreams"], reversed: ["confusion", "fear", "misinterpretation"] },
        upright: "Illusion and the unconscious mind. Things are not as they seem. Trust your instincts.",
        reversed: "Confusion lifting or fears being confronted. Clarity emerging from darkness."
    },
    "major-19": {
        keywords: { upright: ["joy", "success", "celebration", "positivity"], reversed: ["negativity", "depression", "sadness"] },
        upright: "Joy, success, and positivity. Celebration and everything coming together harmoniously.",
        reversed: "Temporary depression or blocked happiness. The sun is still there."
    },
    "major-20": {
        keywords: { upright: ["reflection", "reckoning", "awakening", "renewal"], reversed: ["lack of self awareness", "doubt", "self loathing"] },
        upright: "Reflection and spiritual awakening. Answering a calling or experiencing rebirth.",
        reversed: "Lack of self-awareness or refusing to learn from the past."
    },
    "major-21": {
        keywords: { upright: ["fulfillment", "harmony", "completion", "accomplishment"], reversed: ["incompletion", "no closure", "lack of achievement"] },
        upright: "Completion, fulfillment, and wholeness. The successful end of a cycle.",
        reversed: "Incompletion or feeling like something is missing."
    },
    "wands-01": {
        keywords: { upright: ["creation", "willpower", "inspiration", "desire"], reversed: ["lack of energy", "lack of passion", "boredom"] },
        upright: "A new beginning filled with inspiration and creative energy. The spark of a new idea.",
        reversed: "Lack of energy, creative blocks, or delays in new ventures."
    },
    "wands-02": {
        keywords: { upright: ["planning", "making decisions", "leaving home"], reversed: ["fear of change", "playing safe", "bad planning"] },
        upright: "Planning for the future and making decisions about which path to take.",
        reversed: "Fear of the unknown or reluctance to leave your comfort zone."
    },
    "wands-03": {
        keywords: { upright: ["looking ahead", "expansion", "rapid growth"], reversed: ["obstacles", "delays", "frustration"] },
        upright: "Expansion and looking ahead to future opportunities. Progress is being made.",
        reversed: "Delays, obstacles, or frustration with the pace of progress."
    },
    "wands-04": {
        keywords: { upright: ["community", "home", "celebration", "harmony"], reversed: ["lack of support", "transience", "home conflicts"] },
        upright: "Celebration, homecoming, and community. A milestone achieved.",
        reversed: "Lack of support or conflicts at home."
    },
    "wands-05": {
        keywords: { upright: ["competition", "rivalry", "conflict"], reversed: ["avoiding conflict", "respecting differences"] },
        upright: "Competition and differing opinions. Healthy rivalry or frustrating disagreements.",
        reversed: "Avoiding conflict or finding common ground."
    },
    "wands-06": {
        keywords: { upright: ["victory", "success", "public reward"], reversed: ["excess pride", "lack of recognition", "fall from grace"] },
        upright: "Victory and public recognition. Your efforts are being acknowledged.",
        reversed: "Lack of recognition or success that feels hollow."
    },
    "wands-07": {
        keywords: { upright: ["perseverance", "defensive", "maintaining control"], reversed: ["give up", "destroyed confidence", "overwhelmed"] },
        upright: "Standing your ground and persevering despite opposition.",
        reversed: "Feeling overwhelmed or losing confidence."
    },
    "wands-08": {
        keywords: { upright: ["rapid action", "movement", "quick decisions"], reversed: ["panic", "waiting", "slowdown"] },
        upright: "Rapid movement and things happening quickly. Travel and momentum.",
        reversed: "Delays or feeling stuck."
    },
    "wands-09": {
        keywords: { upright: ["resilience", "grit", "last stand"], reversed: ["exhaustion", "fatigue", "questioning motivations"] },
        upright: "Resilience and determination. You've been through challenges but are still standing.",
        reversed: "Exhaustion or questioning whether it's worth continuing."
    },
    "wands-10": {
        keywords: { upright: ["accomplishment", "responsibility", "burden"], reversed: ["inability to delegate", "overstressed", "burnt out"] },
        upright: "Heavy burdens and responsibility. You may be taking on too much.",
        reversed: "Burnout or being crushed by responsibilities."
    },
    "wands-11": {
        keywords: { upright: ["exploration", "excitement", "freedom"], reversed: ["lack of direction", "procrastination", "creating conflict"] },
        upright: "Exploration and discovering new passions. A message about creativity.",
        reversed: "Lack of direction or enthusiasm without follow-through."
    },
    "wands-12": {
        keywords: { upright: ["action", "adventure", "fearlessness"], reversed: ["anger", "impulsiveness", "recklessness"] },
        upright: "Energy, passion, and charging forward fearlessly toward goals.",
        reversed: "Recklessness or energy that's scattered."
    },
    "wands-13": {
        keywords: { upright: ["courage", "determination", "joy"], reversed: ["selfishness", "jealousy", "insecurities"] },
        upright: "Confidence and warmth. Someone who inspires others with courage and joy.",
        reversed: "Jealousy or insecurity masked by bravado."
    },
    "wands-14": {
        keywords: { upright: ["big picture", "leader", "overcoming challenges"], reversed: ["impulsive", "overbearing", "unachievable expectations"] },
        upright: "Visionary leadership and seeing the big picture. Inspiring action.",
        reversed: "Impulsive decisions or setting unrealistic expectations."
    },
    "cups-01": {
        keywords: { upright: ["new feelings", "spirituality", "intuition"], reversed: ["emotional loss", "blocked creativity", "emptiness"] },
        upright: "New emotional beginnings and spiritual connection. Overflowing feelings.",
        reversed: "Emotional blockages or spiritual disconnection."
    },
    "cups-02": {
        keywords: { upright: ["unity", "partnership", "connection"], reversed: ["imbalance", "broken communication", "tension"] },
        upright: "Partnership and deep connection. The beginning of a meaningful relationship.",
        reversed: "Imbalance in relationships or broken communication."
    },
    "cups-03": {
        keywords: { upright: ["friendship", "community", "happiness"], reversed: ["overindulgence", "gossip", "isolation"] },
        upright: "Celebration, friendship, and shared joy.",
        reversed: "Overindulgence or feeling isolated from community."
    },
    "cups-04": {
        keywords: { upright: ["apathy", "contemplation", "disconnectedness"], reversed: ["sudden awareness", "choosing happiness", "acceptance"] },
        upright: "Contemplation or missing opportunities. A need for introspection.",
        reversed: "Sudden awareness or choosing to engage with life again."
    },
    "cups-05": {
        keywords: { upright: ["loss", "grief", "self-pity"], reversed: ["acceptance", "moving on", "finding peace"] },
        upright: "Loss and focusing on what's gone rather than what remains.",
        reversed: "Acceptance and moving on from loss."
    },
    "cups-06": {
        keywords: { upright: ["familiarity", "happy memories", "healing"], reversed: ["moving forward", "leaving home", "independence"] },
        upright: "Nostalgia and happy memories. Healing through familiar comfort.",
        reversed: "Leaving the past behind and gaining independence."
    },
    "cups-07": {
        keywords: { upright: ["searching for purpose", "choices", "daydreaming"], reversed: ["lack of purpose", "diversion", "confusion"] },
        upright: "Many options before you. Discernment needed to separate illusion from reality.",
        reversed: "Overwhelm from too many choices or lacking clear purpose."
    },
    "cups-08": {
        keywords: { upright: ["walking away", "disillusionment", "leaving behind"], reversed: ["avoidance", "fear of change", "fear of loss"] },
        upright: "Walking away from what no longer serves you. Seeking deeper meaning.",
        reversed: "Fear of leaving or avoidance of necessary change."
    },
    "cups-09": {
        keywords: { upright: ["satisfaction", "emotional stability", "luxury"], reversed: ["lack of inner joy", "smugness", "dissatisfaction"] },
        upright: "Emotional satisfaction and wishes coming true. Enjoying your efforts.",
        reversed: "Superficial happiness or dissatisfaction despite having what you wanted."
    },
    "cups-10": {
        keywords: { upright: ["inner happiness", "fulfillment", "dreams coming true"], reversed: ["shattered dreams", "broken family", "domestic disharmony"] },
        upright: "Emotional fulfillment and lasting happiness.",
        reversed: "Family discord or broken dreams."
    },
    "cups-11": {
        keywords: { upright: ["happy surprise", "dreamer", "sensitivity"], reversed: ["emotional immaturity", "insecurity", "disappointment"] },
        upright: "Creative opportunities and emotional sensitivity. A dreamer.",
        reversed: "Emotional immaturity or sensitivity without boundaries."
    },
    "cups-12": {
        keywords: { upright: ["following the heart", "idealist", "romantic"], reversed: ["moodiness", "disappointment", "unrealistic expectations"] },
        upright: "Following your heart and seeking beauty. An idealistic person.",
        reversed: "Moodiness or unrealistic romantic expectations."
    },
    "cups-13": {
        keywords: { upright: ["compassion", "calm", "comfort"], reversed: ["martyrdom", "insecurity", "dependence"] },
        upright: "Compassion and emotional security. A nurturing presence.",
        reversed: "Emotional insecurity or giving too much at your own expense."
    },
    "cups-14": {
        keywords: { upright: ["compassion", "control", "balance"], reversed: ["coldness", "moodiness", "bad advice"] },
        upright: "Emotional balance and diplomacy. Mastery over emotions while remaining caring.",
        reversed: "Emotional manipulation or using emotional intelligence selfishly."
    },
    "swords-01": {
        keywords: { upright: ["breakthrough", "clarity", "sharp mind"], reversed: ["confusion", "brutality", "chaos"] },
        upright: "Mental clarity and breakthrough. The power of truth and understanding.",
        reversed: "Confusion or using intellect cruelly."
    },
    "swords-02": {
        keywords: { upright: ["difficult choices", "indecision", "stalemate"], reversed: ["lesser of two evils", "no right choice", "confusion"] },
        upright: "Difficult decisions and being caught between two options.",
        reversed: "Forced choice or finally making a decision you've been avoiding."
    },
    "swords-03": {
        keywords: { upright: ["heartbreak", "suffering", "grief"], reversed: ["recovery", "forgiveness", "moving on"] },
        upright: "Heartbreak and emotional pain from loss or betrayal.",
        reversed: "Recovery from heartbreak and the healing process beginning."
    },
    "swords-04": {
        keywords: { upright: ["rest", "restoration", "contemplation"], reversed: ["restlessness", "burnout", "stress"] },
        upright: "Rest and recovery. A necessary period to heal and restore energy.",
        reversed: "Restlessness or burnout from not taking needed breaks."
    },
    "swords-05": {
        keywords: { upright: ["unbridled ambition", "win at all costs", "sneakiness"], reversed: ["lingering resentment", "desire to reconcile", "forgiveness"] },
        upright: "Conflict and winning at any cost. A hollow victory.",
        reversed: "Desire to reconcile or letting go of conflict."
    },
    "swords-06": {
        keywords: { upright: ["transition", "leaving behind", "moving on"], reversed: ["emotional baggage", "unresolved issues", "resisting transition"] },
        upright: "Transition and moving away from difficulty. A journey toward calmer waters.",
        reversed: "Resisting necessary change or carrying emotional baggage."
    },
    "swords-07": {
        keywords: { upright: ["deception", "trickery", "tactics and strategy"], reversed: ["coming clean", "rethinking approach", "deception revealed"] },
        upright: "Deception and using cunning to achieve goals.",
        reversed: "Deception revealed or rethinking a sneaky approach."
    },
    "swords-08": {
        keywords: { upright: ["imprisonment", "entrapment", "self-victimization"], reversed: ["self acceptance", "new perspective", "freedom"] },
        upright: "Feeling trapped. Often the imprisonment is self-imposed.",
        reversed: "Freedom from mental prison or realizing you had the power to leave."
    },
    "swords-09": {
        keywords: { upright: ["anxiety", "hopelessness", "trauma"], reversed: ["hope", "reaching out", "despair lifting"] },
        upright: "Anxiety and worry. The darkest hour when fears seem overwhelming.",
        reversed: "Light at the end of the tunnel or anxiety beginning to lift."
    },
    "swords-10": {
        keywords: { upright: ["failure", "collapse", "defeat"], reversed: ["can't get worse", "only upwards", "inevitable end"] },
        upright: "Rock bottom. The worst has happened, but now there's nowhere to go but up.",
        reversed: "The worst is over or recovery beginning."
    },
    "swords-11": {
        keywords: { upright: ["curiosity", "restlessness", "mental energy"], reversed: ["deception", "manipulation", "all talk"] },
        upright: "Curiosity and new ideas. A messenger bringing intellectual challenges.",
        reversed: "All talk and no action or using words to manipulate."
    },
    "swords-12": {
        keywords: { upright: ["action", "impulsiveness", "defending beliefs"], reversed: ["no direction", "disregard for consequences", "unpredictability"] },
        upright: "Swift action and charging forward. Someone who acts quickly on ideas.",
        reversed: "Reckless action or disregard for consequences."
    },
    "swords-13": {
        keywords: { upright: ["complexity", "perceptiveness", "clear mindedness"], reversed: ["cold hearted", "cruel", "bitterness"] },
        upright: "Clear thinking and direct communication. Seeing through deception.",
        reversed: "Coldness or using sharp intellect to hurt others."
    },
    "swords-14": {
        keywords: { upright: ["head over heart", "discipline", "truth"], reversed: ["manipulative", "cruel", "weakness"] },
        upright: "Intellectual authority and clear judgment. Leading with logic.",
        reversed: "Manipulation through intellect or tyrannical use of power."
    },
    "pentacles-01": {
        keywords: { upright: ["opportunity", "prosperity", "new venture"], reversed: ["lost opportunity", "missed chance", "bad investment"] },
        upright: "New financial or material opportunity. The seed of prosperity.",
        reversed: "Missed opportunity or failed financial venture."
    },
    "pentacles-02": {
        keywords: { upright: ["balancing decisions", "priorities", "adapting to change"], reversed: ["loss of balance", "disorganized", "overwhelmed"] },
        upright: "Juggling priorities and managing responsibilities with flexibility.",
        reversed: "Loss of balance or dropping the ball on important matters."
    },
    "pentacles-03": {
        keywords: { upright: ["teamwork", "collaboration", "building"], reversed: ["lack of teamwork", "disorganized", "group conflict"] },
        upright: "Collaboration and skilled work. Teamwork leading to quality results.",
        reversed: "Lack of cooperation or conflicts within a team."
    },
    "pentacles-04": {
        keywords: { upright: ["conservation", "frugality", "security"], reversed: ["greediness", "stinginess", "possessiveness"] },
        upright: "Security and protecting what you have, sometimes too tightly.",
        reversed: "Greed or holding on too tightly to possessions."
    },
    "pentacles-05": {
        keywords: { upright: ["need", "poverty", "insecurity"], reversed: ["recovery", "charity", "improvement"] },
        upright: "Financial hardship or feeling left out in the cold.",
        reversed: "Recovery from hardship or finding help."
    },
    "pentacles-06": {
        keywords: { upright: ["charity", "generosity", "sharing"], reversed: ["strings attached", "stinginess", "power and domination"] },
        upright: "Generosity and the balance of giving and receiving.",
        reversed: "Generosity with strings attached or using charity for power."
    },
    "pentacles-07": {
        keywords: { upright: ["hard work", "perseverance", "diligence"], reversed: ["work without results", "distractions", "lack of rewards"] },
        upright: "Patience and evaluating progress. Taking the long view.",
        reversed: "Frustration with slow progress or lack of results."
    },
    "pentacles-08": {
        keywords: { upright: ["apprenticeship", "passion", "high standards"], reversed: ["lack of passion", "uninspired", "no motivation"] },
        upright: "Skill development and dedication to craft.",
        reversed: "Lack of motivation or feeling uninspired."
    },
    "pentacles-09": {
        keywords: { upright: ["fruits of labor", "rewards", "luxury"], reversed: ["reckless spending", "living beyond means", "false success"] },
        upright: "Enjoying rewards of hard work. Material comfort and independence.",
        reversed: "Living beyond your means or hollow success."
    },
    "pentacles-10": {
        keywords: { upright: ["legacy", "culmination", "inheritance"], reversed: ["fleeting success", "lack of stability", "lack of resources"] },
        upright: "Legacy and family wealth. The culmination of material achievement.",
        reversed: "Family financial troubles or unstable foundations."
    },
    "pentacles-11": {
        keywords: { upright: ["ambition", "desire", "diligence"], reversed: ["lack of commitment", "greediness", "laziness"] },
        upright: "New opportunities for prosperity. A message about finances or career.",
        reversed: "Laziness or greed without the work to back it up."
    },
    "pentacles-12": {
        keywords: { upright: ["efficiency", "hard work", "responsibility"], reversed: ["laziness", "obsessiveness", "work without reward"] },
        upright: "Hard work and steady progress. Getting things done through dedication.",
        reversed: "Being stuck in routine or working without seeing results."
    },
    "pentacles-13": {
        keywords: { upright: ["practicality", "creature comforts", "financial security"], reversed: ["self-centeredness", "jealousy", "smothering"] },
        upright: "Practical nurturing and creating a comfortable home.",
        reversed: "Neglecting home life or jealousy over others' success."
    },
    "pentacles-14": {
        keywords: { upright: ["abundance", "prosperity", "security"], reversed: ["greed", "indulgence", "sensuality"] },
        upright: "Material success and abundance through discipline.",
        reversed: "Greed or using wealth for status rather than substance."
    }
};

function getDisplayNumber(card) {
    if (card.arcana === 'Major') return card.number.toString();
    const court = { 11: 'Pg', 12: 'Kn', 13: 'Q', 14: 'K' };
    return court[card.number] || card.number.toString();
}

function getCardFrontContent(card) {
    if (USE_IMAGES) {
        const url = getCardImageUrl(card);
        if (url) return `<img src="${url}" alt="${card.name}" loading="lazy">`;
    }
    return `<div class="card-placeholder"><div class="card-number">${getDisplayNumber(card)}</div><div class="card-suit">${card.suit || 'Major'}</div></div>`;
}

function getModalContent(card) {
    if (USE_IMAGES) {
        const url = getCardImageUrl(card);
        if (url) return `<img src="${url}" alt="${card.name}">`;
    }
    return `<div class="modal-placeholder"><div class="card-number">${getDisplayNumber(card)}</div><div class="card-suit">${card.suit || 'Major Arcana'}</div></div>`;
}

// State
let deck = [];
let placedCards = [];
let draggedCard = null;
let dragOffset = { x: 0, y: 0 };
let reversalsEnabled = false;
let currentReadingId = null;

// LocalStorage keys
const STORAGE_KEYS = {
    PREFERENCES: 'tarot_preferences',
    CURRENT_READING: 'tarot_current_reading',
    READING_HISTORY: 'tarot_reading_history'
};

// ============================================
// LOCALSTORAGE FUNCTIONS
// ============================================

function savePreferences() {
    const prefs = {
        theme: document.body.classList.contains('dark') ? 'dark' : 'light',
        reversalsEnabled: reversalsEnabled,
        devMode: document.body.classList.contains('dev-mode')
    };
    localStorage.setItem(STORAGE_KEYS.PREFERENCES, JSON.stringify(prefs));
}

function loadPreferences() {
    try {
        const prefs = JSON.parse(localStorage.getItem(STORAGE_KEYS.PREFERENCES));
        if (prefs) {
            // Theme
            if (prefs.theme === 'dark') {
                document.body.classList.add('dark');
                updateThemeIcon(true);
            }
            // Reversals
            if (prefs.reversalsEnabled) {
                reversalsEnabled = true;
                reversalsToggle.classList.add('active');
            }
            // Dev mode
            if (prefs.devMode) {
                document.body.classList.add('dev-mode');
                devToggle.classList.add('active');
            }
        }
    } catch (e) {
        console.warn('Could not load preferences:', e);
    }
}

function saveCurrentReading() {
    if (placedCards.length === 0 && textBoxes.length === 0 && !currentSpread) {
        localStorage.removeItem(STORAGE_KEYS.CURRENT_READING);
        return;
    }
    
    const surfaceRect = readingSurface.getBoundingClientRect();
    
    const reading = {
        id: currentReadingId || generateReadingId(),
        timestamp: Date.now(),
        spreadId: currentSpread ? currentSpread.id : null,
        cards: placedCards.map(p => ({
            cardId: p.card.id,
            percentX: parseFloat(p.element.dataset.percentX) || 0,
            percentY: parseFloat(p.element.dataset.percentY) || 0,
            isFlipped: p.element.classList.contains('flipped'),
            isReversed: p.element.classList.contains('reversed')
        })),
        textBoxes: textBoxes.map(tb => {
            const textarea = tb.element.querySelector('.text-box-content');
            // Convert pixel positions to percentages
            const percentX = (tb.element.offsetLeft / surfaceRect.width) * 100;
            const percentY = (tb.element.offsetTop / surfaceRect.height) * 100;
            const percentW = (tb.element.offsetWidth / surfaceRect.width) * 100;
            const percentH = (tb.element.offsetHeight / surfaceRect.height) * 100;
            return {
                id: tb.id,
                percentX,
                percentY,
                percentW,
                percentH,
                content: textarea ? textarea.value : '',
                fontSize: tb.fontSize || 13,
                showBorder: tb.element.classList.contains('show-border')
            };
        }),
        deckOrder: deck.map(c => c.id)
    };
    
    currentReadingId = reading.id;
    localStorage.setItem(STORAGE_KEYS.CURRENT_READING, JSON.stringify(reading));
}

function loadCurrentReading() {
    try {
        const reading = JSON.parse(localStorage.getItem(STORAGE_KEYS.CURRENT_READING));
        if (reading && (
            (reading.cards && reading.cards.length > 0) || 
            (reading.textBoxes && reading.textBoxes.length > 0) ||
            reading.spreadId
        )) {
            return reading;
        }
    } catch (e) {
        console.warn('Could not load current reading:', e);
    }
    return null;
}

function restoreReading(reading) {
    // Clear current cards and text boxes but keep Aa button
    placedCards.forEach(p => p.element.remove());
    textBoxes.forEach(tb => tb.element.remove());
    placedCards = [];
    textBoxes = [];
    textBoxIdCounter = 0;
    currentReadingId = reading.id;
    
    // Restore spread
    if (reading.spreadId && SPREADS[reading.spreadId]) {
        currentSpread = SPREADS[reading.spreadId];
    } else {
        currentSpread = null;
    }
    clearSpreadSlots();
    
    // Restore deck order
    if (reading.deckOrder) {
        deck = reading.deckOrder.map(id => TAROT_DECK.find(c => c.id === id)).filter(Boolean);
    }
    
    // Restore placed cards
    if (reading.cards) {
        reading.cards.forEach(savedCard => {
            const cardData = TAROT_DECK.find(c => c.id === savedCard.cardId);
            if (cardData) {
                // Remove from deck if present
                deck = deck.filter(c => c.id !== savedCard.cardId);
                
                // Create and place card
                const el = document.createElement('div');
                el.className = 'placed-card card';
                if (savedCard.isFlipped) el.classList.add('flipped');
                if (savedCard.isReversed) el.classList.add('reversed');
                el.dataset.cardId = cardData.id;
                el.style.left = savedCard.percentX + '%';
                el.style.top = savedCard.percentY + '%';
                el.dataset.percentX = savedCard.percentX;
                el.dataset.percentY = savedCard.percentY;
                el.style.animation = 'none'; // Skip grow animation on restore
                
                el.innerHTML = `
                    <div class="card-face card-back"></div>
                    <div class="card-face card-front">${getCardFrontContent(cardData)}</div>
                    <div class="dev-label">${cardData.id}</div>
                `;
                
                // Add event handlers
                addPlacedCardHandlers(el, cardData);
                
                readingSurfaceContent.appendChild(el);
                placedCards.push({ card: cardData, element: el });
            }
        });
    }
    
    // Restore text boxes
    if (reading.textBoxes && reading.textBoxes.length > 0) {
        reading.textBoxes.forEach(savedBox => {
            restoreTextBox(savedBox);
        });
    }
    
    if (placedCards.length > 0) {
        readingSurface.classList.add('has-cards');
        document.querySelector('.deck-area').classList.add('docked');
    } else {
        readingSurface.classList.remove('has-cards');
        document.querySelector('.deck-area').classList.remove('docked');
    }
    
    // Render spread slots after cards are placed
    if (currentSpread) {
        renderSpreadSlots();
    }
    
    renderDeck();
    updateDevPanel();
}

function generateReadingId() {
    return 'reading_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

function saveToHistory(title = '') {
    if (placedCards.length === 0 && textBoxes.length === 0) return null;
    
    const surfaceRect = readingSurface.getBoundingClientRect();
    
    const reading = {
        id: currentReadingId || generateReadingId(),
        title: title || `Reading - ${new Date().toLocaleDateString()}`,
        timestamp: Date.now(),
        spreadId: currentSpread ? currentSpread.id : null,
        cards: placedCards.map(p => ({
            cardId: p.card.id,
            cardName: p.card.name,
            percentX: parseFloat(p.element.dataset.percentX) || 0,
            percentY: parseFloat(p.element.dataset.percentY) || 0,
            isFlipped: p.element.classList.contains('flipped'),
            isReversed: p.element.classList.contains('reversed')
        })),
        textBoxes: textBoxes.map(tb => {
            const textarea = tb.element.querySelector('.text-box-content');
            const percentX = (tb.element.offsetLeft / surfaceRect.width) * 100;
            const percentY = (tb.element.offsetTop / surfaceRect.height) * 100;
            const percentW = (tb.element.offsetWidth / surfaceRect.width) * 100;
            const percentH = (tb.element.offsetHeight / surfaceRect.height) * 100;
            return {
                id: tb.id,
                percentX,
                percentY,
                percentW,
                percentH,
                content: textarea ? textarea.value : '',
                fontSize: tb.fontSize || 13,
                showBorder: tb.element.classList.contains('show-border')
            };
        }),
        deckOrder: deck.map(c => c.id)
    };
    
    try {
        let history = JSON.parse(localStorage.getItem(STORAGE_KEYS.READING_HISTORY)) || [];
        
        // Update existing or add new
        const existingIndex = history.findIndex(r => r.id === reading.id);
        if (existingIndex >= 0) {
            history[existingIndex] = reading;
        } else {
            history.unshift(reading);
        }
        
        // Keep only last 50 readings
        history = history.slice(0, 50);
        
        localStorage.setItem(STORAGE_KEYS.READING_HISTORY, JSON.stringify(history));
        return reading.id;
    } catch (e) {
        console.warn('Could not save to history:', e);
        return null;
    }
}

function getReadingHistory() {
    try {
        return JSON.parse(localStorage.getItem(STORAGE_KEYS.READING_HISTORY)) || [];
    } catch (e) {
        return [];
    }
}

function deleteFromHistory(readingId) {
    try {
        let history = JSON.parse(localStorage.getItem(STORAGE_KEYS.READING_HISTORY)) || [];
        history = history.filter(r => r.id !== readingId);
        localStorage.setItem(STORAGE_KEYS.READING_HISTORY, JSON.stringify(history));
    } catch (e) {
        console.warn('Could not delete from history:', e);
    }
}

function clearAllData() {
    Object.values(STORAGE_KEYS).forEach(key => localStorage.removeItem(key));
    currentReadingId = null;
}

// ============================================
// END LOCALSTORAGE FUNCTIONS
// ============================================

// DOM
const deckContainer = document.getElementById('deckContainer');
const readingSurface = document.getElementById('readingSurface');
const devToggle = document.getElementById('devToggle');
const reversalsToggle = document.getElementById('reversalsToggle');
const themeToggle = document.getElementById('themeToggle');
const shuffleBtn = document.getElementById('shuffleBtn');
const resetBtn = document.getElementById('resetBtn');
const cardModal = document.getElementById('cardModal');
const modalClose = document.getElementById('modalClose');
const devInfo = document.getElementById('devInfo');
const validationStatus = document.getElementById('validationStatus');

// Save/History DOM
const saveBtn = document.getElementById('saveBtn');
const saveModal = document.getElementById('saveModal');
const readingTitleInput = document.getElementById('readingTitleInput');
const saveCancelBtn = document.getElementById('saveCancelBtn');
const saveConfirmBtn = document.getElementById('saveConfirmBtn');
const historyBtn = document.getElementById('historyBtn');
const historyPanel = document.getElementById('historyPanel');
const historyOverlay = document.getElementById('historyOverlay');
const historyClose = document.getElementById('historyClose');
const historyList = document.getElementById('historyList');
const historyEmpty = document.getElementById('historyEmpty');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');

// Text Tool DOM
const textToolBtn = document.getElementById('textToolBtn');

// Fisher-Yates with crypto
function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const buf = new Uint32Array(1);
        crypto.getRandomValues(buf);
        const j = buf[0] % (i + 1);
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

function initializeDeck() {
    deck = shuffleArray([...TAROT_DECK]);
    placedCards = [];
    renderDeck();
    updateDevPanel();
}

function getCardDimensions() {
    const style = getComputedStyle(document.documentElement);
    const cardW = parseFloat(style.getPropertyValue('--deck-card-width')) || 56;
    const overlap = parseFloat(style.getPropertyValue('--card-overlap')) || 9;
    return { cardW, overlap };
}

function isMobileView() {
    return window.innerWidth <= 600;
}

// Helper: Calculate and apply card positions in deck layout
function applyDeckLayout(cards, cardW, overlap, onCard) {
    const total = cards.length;
    
    if (isMobileView() && total > 20) {
        // Two arched rows for mobile - both arch upward
        const half = Math.ceil(total / 2);
        const topRow = cards.slice(0, half);
        const bottomRow = cards.slice(half);
        const arcHeight = 20;
        const maxRotation = 15;
        
        // Top row
        const topTotalW = cardW + (topRow.length - 1) * overlap;
        const topStartX = -topTotalW / 2 + cardW / 2;
        
        topRow.forEach((card, i) => {
            const xPos = topStartX + i * overlap;
            const progress = topRow.length > 1 ? i / (topRow.length - 1) : 0.5;
            const arcY = -Math.sin(progress * Math.PI) * arcHeight;
            const rotation = (progress - 0.5) * maxRotation * 2;
            onCard(card, i, { xPos, arcY, rotation, top: '30%' });
        });
        
        // Bottom row
        const bottomTotalW = cardW + (bottomRow.length - 1) * overlap;
        const bottomStartX = -bottomTotalW / 2 + cardW / 2;
        
        bottomRow.forEach((card, i) => {
            const globalIndex = half + i;
            const xPos = bottomStartX + i * overlap;
            const progress = bottomRow.length > 1 ? i / (bottomRow.length - 1) : 0.5;
            const arcY = -Math.sin(progress * Math.PI) * arcHeight;
            const rotation = (progress - 0.5) * maxRotation * 2;
            onCard(card, globalIndex, { xPos, arcY, rotation, top: '72%' });
        });
    } else {
        // Single row (desktop)
        const totalW = cardW + (total - 1) * overlap;
        const startX = -totalW / 2 + cardW / 2;
        
        cards.forEach((card, i) => {
            const xPos = startX + i * overlap;
            onCard(card, i, { xPos, arcY: 0, rotation: 0, top: '50%' });
        });
    }
}

function renderDeck() {
    deckContainer.innerHTML = '';
    const { cardW, overlap } = getCardDimensions();
    
    applyDeckLayout(deck, cardW, overlap, (card, index, pos) => {
        const el = createCardElement(card, index);
        el.style.left = '50%';
        el.style.top = pos.top;
        el.style.transform = `translate(-50%, -50%) translateX(${pos.xPos}px)${pos.arcY ? ` translateY(${pos.arcY}px)` : ''}${pos.rotation ? ` rotate(${pos.rotation}deg)` : ''}`;
        el.style.setProperty('--base-x', `${pos.xPos}px`);
        if (pos.arcY) el.style.setProperty('--base-y', `${pos.arcY}px`);
        if (pos.rotation) el.style.setProperty('--base-rot', `${pos.rotation}deg`);
        el.style.zIndex = index;
        deckContainer.appendChild(el);
    });
}

function createCardElement(card, index) {
    const el = document.createElement('div');
    el.className = 'card';
    el.dataset.cardId = card.id;
    el.dataset.index = index;
    el.innerHTML = `
        <div class="card-face card-back"></div>
        <div class="card-face card-front">${getCardFrontContent(card)}</div>
        <div class="dev-label">${card.id}</div>
    `;
    el.addEventListener('mousedown', startDrag);
    el.addEventListener('touchstart', handleDeckTouchStart, { passive: false });
    return el;
}

// Mobile Arc Selection State
let arcSelectionState = null;
let stagedCard = null; // Card waiting to be placed

function triggerHaptic(style = 'light') {
    // Try iOS Haptic Engine first (for PWA/web apps with haptic support)
    if (window.webkit?.messageHandlers?.haptic) {
        window.webkit.messageHandlers.haptic.postMessage(style);
        return;
    }
    
    // Fallback to Vibration API (Android, some browsers)
    if (navigator.vibrate) {
        switch(style) {
            case 'light': navigator.vibrate(8); break;
            case 'medium': navigator.vibrate(15); break;
            case 'heavy': navigator.vibrate(30); break;
            case 'tick': navigator.vibrate(4); break;
        }
    }
}

function handleDeckTouchStart(e) {
    // If there's already a staged card, use normal drag for desktop-style interaction
    if (stagedCard) {
        startDrag(e);
        return;
    }
    
    // On desktop-sized screens, use normal drag
    if (!isMobileView()) {
        startDrag(e);
        return;
    }
    
    e.preventDefault();
    const touch = e.touches[0];
    const startX = touch.clientX;
    const startY = touch.clientY;
    const startTime = Date.now();
    
    let longPressTriggered = false;
    let hasMoved = false;
    
    // Long press detection
    const longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        triggerHaptic('medium');
        initArcSelection(touch.clientX);
    }, 300); // 300ms for long press
    
    const onTouchMove = (e) => {
        const touch = e.touches[0];
        const dx = touch.clientX - startX;
        const dy = touch.clientY - startY;
        
        // If moved too much before long press, cancel and start normal drag
        if (!longPressTriggered && (Math.abs(dx) > 10 || Math.abs(dy) > 10)) {
            hasMoved = true;
            clearTimeout(longPressTimer);
            cleanup();
            startDrag(e);
            return;
        }
        
        // If in arc selection mode, handle rotation
        if (longPressTriggered && arcSelectionState) {
            e.preventDefault();
            handleArcRotation(touch.clientX);
        }
    };
    
    const onTouchEnd = (e) => {
        clearTimeout(longPressTimer);
        
        if (longPressTriggered && arcSelectionState) {
            // Check for swipe up
            const touch = e.changedTouches[0];
            const dy = touch.clientY - startY;
            
            if (dy < -30) {
                // Swipe up - stage the selected card
                stageSelectedCard();
            } else {
                // Just released - cancel selection
                cancelArcSelection();
            }
        }
        
        cleanup();
    };
    
    const cleanup = () => {
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
    };
    
    document.addEventListener('touchmove', onTouchMove, { passive: false });
    document.addEventListener('touchend', onTouchEnd);
}

function initArcSelection(clientX) {
    const cards = Array.from(deckContainer.querySelectorAll('.card'));
    if (cards.length === 0) return;
    
    deckContainer.classList.add('arc-selection-active');
    
    // Calculate which card is nearest to touch
    const centerIndex = findNearestCardIndex(clientX, cards);
    
    arcSelectionState = {
        cards,
        currentIndex: centerIndex,
        startX: clientX,
        lastX: clientX
    };
    
    updateArcCenteredCard(centerIndex);
}

function findNearestCardIndex(clientX, cards) {
    let nearestIndex = 0;
    let nearestDist = Infinity;
    
    cards.forEach((card, i) => {
        const rect = card.getBoundingClientRect();
        const cardCenterX = rect.left + rect.width / 2;
        const dist = Math.abs(clientX - cardCenterX);
        if (dist < nearestDist) {
            nearestDist = dist;
            nearestIndex = i;
        }
    });
    
    return nearestIndex;
}

function handleArcRotation(clientX) {
    if (!arcSelectionState) return;
    
    const { cards, currentIndex, lastX } = arcSelectionState;
    const dx = clientX - lastX;
    
    // Determine card width for sensitivity
    const cardWidth = cards[0]?.getBoundingClientRect().width || 60;
    const sensitivity = cardWidth * 0.6; // Move ~60% of card width to switch
    
    arcSelectionState.accumulatedDx = (arcSelectionState.accumulatedDx || 0) + dx;
    arcSelectionState.lastX = clientX;
    
    // Check if we've moved enough to switch cards
    if (Math.abs(arcSelectionState.accumulatedDx) > sensitivity) {
        const direction = arcSelectionState.accumulatedDx > 0 ? -1 : 1; // Swipe right = previous card
        const newIndex = Math.max(0, Math.min(cards.length - 1, currentIndex + direction));
        
        if (newIndex !== currentIndex) {
            arcSelectionState.currentIndex = newIndex;
            arcSelectionState.accumulatedDx = 0;
            triggerHaptic('tick');
            updateArcCenteredCard(newIndex);
        }
    }
}

function updateArcCenteredCard(index) {
    if (!arcSelectionState) return;
    
    arcSelectionState.cards.forEach((card, i) => {
        if (i === index) {
            card.classList.add('arc-centered');
        } else {
            card.classList.remove('arc-centered');
        }
    });
}

function stageSelectedCard() {
    if (!arcSelectionState) return;
    
    const { cards, currentIndex } = arcSelectionState;
    const selectedCard = cards[currentIndex];
    
    if (selectedCard) {
        triggerHaptic('medium');
        
        // Remove centered class, add staged class
        selectedCard.classList.remove('arc-centered');
        selectedCard.classList.add('card-staged');
        
        // Store reference to staged card
        stagedCard = selectedCard;
        
        // Dim other cards
        cards.forEach((card, i) => {
            if (i !== currentIndex) {
                card.style.opacity = '0.4';
            }
        });
    }
    
    // Clean up arc selection state
    deckContainer.classList.remove('arc-selection-active');
    arcSelectionState = null;
}

function cancelArcSelection() {
    if (!arcSelectionState) return;
    
    arcSelectionState.cards.forEach(card => {
        card.classList.remove('arc-centered');
    });
    
    deckContainer.classList.remove('arc-selection-active');
    arcSelectionState = null;
}

function cancelStagedCard() {
    if (!stagedCard) return;
    
    stagedCard.classList.remove('card-staged');
    stagedCard = null;
    
    // Restore opacity of all deck cards
    const cards = deckContainer.querySelectorAll('.card');
    cards.forEach(card => {
        card.style.opacity = '';
    });
}

// Tap on deck area (not on a card) to cancel staged card
document.querySelector('.deck-area').addEventListener('touchstart', e => {
    if (!stagedCard) return;
    
    // If tapping directly on the deck area (not on a card), cancel
    if (!e.target.closest('.card')) {
        e.preventDefault();
        triggerHaptic('light');
        cancelStagedCard();
    }
}, { passive: false });

function startDrag(e) {
    if (e.target.closest('.placed-card.flipped')) return;
    e.preventDefault();
    const el = e.target.closest('.card');
    if (!el) return;

    draggedCard = el;
    
    // Get current visual position before changing anything
    const rect = el.getBoundingClientRect();
    
    // Add dragging classes to disable hover effects and keep deck visible
    draggedCard.classList.add('dragging');
    deckContainer.classList.add('dragging-active');
    deckContainer.closest('.deck-area').classList.add('dragging-active');
    
    // Store original styles to calculate position
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // Move card to body to escape clip-path on deck-container
    document.body.appendChild(draggedCard);
    
    // Apply fixed positioning
    draggedCard.style.position = 'fixed';
    draggedCard.style.left = centerX + 'px';
    draggedCard.style.top = centerY + 'px';
    draggedCard.style.transform = 'translate(-50%, -50%)';
    draggedCard.style.zIndex = '10000';

    const cx = e.clientX || e.touches[0].clientX;
    const cy = e.clientY || e.touches[0].clientY;
    dragOffset.x = cx - centerX;
    dragOffset.y = cy - centerY;

    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchmove', drag, { passive: false });
    document.addEventListener('touchend', endDrag);
}

function drag(e) {
    if (!draggedCard) return;
    e.preventDefault();
    const cx = e.clientX || e.touches[0].clientX;
    const cy = e.clientY || e.touches[0].clientY;
    draggedCard.style.left = (cx - dragOffset.x) + 'px';
    draggedCard.style.top = (cy - dragOffset.y) + 'px';
}

function endDrag(e) {
    if (!draggedCard) return;
    const cx = e.clientX || (e.changedTouches && e.changedTouches[0].clientX);
    const cy = e.clientY || (e.changedTouches && e.changedTouches[0].clientY);
    const surfaceRect = readingSurface.getBoundingClientRect();
    
    const droppedOnSurface = cx >= surfaceRect.left && cx <= surfaceRect.right && 
                             cy >= surfaceRect.top && cy <= surfaceRect.bottom;

    // Remove dragging state from container
    deckContainer.classList.remove('dragging-active');
    deckContainer.closest('.deck-area').classList.remove('dragging-active');

    if (droppedOnSurface) {
        const cardId = draggedCard.dataset.cardId;
        const cardData = deck.find(c => c.id === cardId);
        if (cardData) {
            // Calculate position relative to the content (accounting for zoom/pan)
            // The content is transformed with translate(panX, panY) scale(currentZoom)
            const contentRect = readingSurfaceContent.getBoundingClientRect();
            
            // Get cursor position relative to the transformed content
            const relX = cx - contentRect.left;
            const relY = cy - contentRect.top;
            
            // Convert to unscaled coordinates (the content's internal coordinate system)
            // Since content uses transform-origin: center, and we're placing with percentages,
            // we need the position relative to the content's actual size
            placeCard(cardData, relX / currentZoom, relY / currentZoom);
            deck = deck.filter(c => c.id !== cardId);
            draggedCard.remove();
            updateDevPanel();
        }
    } else {
        // Return card to deck container
        draggedCard.classList.remove('dragging');
        draggedCard.style.position = '';
        draggedCard.style.left = '50%';
        draggedCard.style.top = '50%';
        draggedCard.style.zIndex = draggedCard.dataset.index;
        const xPos = draggedCard.style.getPropertyValue('--base-x') || '0px';
        draggedCard.style.transform = `translate(-50%, -50%) translateX(${xPos})`;
        // Move back to deck container
        deckContainer.appendChild(draggedCard);
    }

    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', endDrag);
    document.removeEventListener('touchmove', drag);
    document.removeEventListener('touchend', endDrag);
    draggedCard = null;
}

function placeCard(card, x, y) {
    const el = document.createElement('div');
    el.className = 'placed-card card';
    el.dataset.cardId = card.id;
    
    // Store position as percentage for responsive scaling
    // Use the surface dimensions (not content, since content is scaled)
    const surfaceRect = readingSurface.getBoundingClientRect();
    let percentX = (x / surfaceRect.width) * 100;
    let percentY = (y / surfaceRect.height) * 100;
    
    // Check for nearby spread slot and snap to it
    const nearestSlot = findNearestSlot(percentX, percentY);
    if (nearestSlot) {
        percentX = nearestSlot.position.percentX;
        percentY = nearestSlot.position.percentY;
    }
    
    el.style.left = percentX + '%';
    el.style.top = percentY + '%';
    el.dataset.percentX = percentX;
    el.dataset.percentY = percentY;
    
    el.innerHTML = `
        <div class="card-face card-back"></div>
        <div class="card-face card-front">${getCardFrontContent(card)}</div>
        <div class="dev-label">${card.id}</div>
    `;
    
    addPlacedCardHandlers(el, card);
    
    readingSurfaceContent.appendChild(el);
    placedCards.push({ card, element: el });
    
    // Hide "Drag cards here" text and dock the deck after first card
    readingSurface.classList.add('has-cards');
    document.querySelector('.deck-area').classList.add('docked');
    
    // Update spread slots filled state
    updateSpreadSlotsFilled();
    clearSlotHighlights();
    
    // Auto-save
    saveCurrentReading();
}

function addPlacedCardHandlers(el, card) {
    // Time-based click vs drag detection
    let mouseDownTime = 0;
    let hasMoved = false;
    let startX, startY, startLeft, startTop;
    const HOLD_THRESHOLD = 150; // ms - anything longer is considered a drag intent
    
    // Helper to get coordinates from mouse or touch event
    function getEventCoords(e, forEnd = false) {
        if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        if (forEnd && e.changedTouches?.[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        return { x: e.clientX, y: e.clientY };
    }
    
    // Shared: Initialize drag state
    function initDrag(coords) {
        mouseDownTime = Date.now();
        hasMoved = false;
        startX = coords.x;
        startY = coords.y;
        
        // Get current position - cards use percentage positioning with transform centering
        const contentRect = readingSurfaceContent.getBoundingClientRect();
        const rect = el.getBoundingClientRect();
        const cardCenterX = rect.left + rect.width / 2 - contentRect.left;
        const cardCenterY = rect.top + rect.height / 2 - contentRect.top;
        startLeft = cardCenterX / currentZoom;
        startTop = cardCenterY / currentZoom;
        
        el.style.zIndex = 100;
    }
    
    // Shared: Handle move during drag
    function handleMove(coords) {
        const elapsed = Date.now() - mouseDownTime;
        if (elapsed >= HOLD_THRESHOLD) {
            hasMoved = true;
            const dx = (coords.x - startX) / currentZoom;
            const dy = (coords.y - startY) / currentZoom;
            const newLeft = startLeft + dx;
            const newTop = startTop + dy;
            el.style.left = newLeft + 'px';
            el.style.top = newTop + 'px';
            
            // Highlight nearest slot during drag
            const surfaceRect = readingSurface.getBoundingClientRect();
            highlightNearestSlot((newLeft / surfaceRect.width) * 100, (newTop / surfaceRect.height) * 100);
        }
    }
    
    // Shared: Handle end of interaction
    function handleEnd(coords) {
        clearSlotHighlights();
        
        if (hasMoved && coords) {
            const deckRect = document.querySelector('.deck-area').getBoundingClientRect();
            if (coords.x >= deckRect.left && coords.x <= deckRect.right && 
                coords.y >= deckRect.top && coords.y <= deckRect.bottom) {
                returnCardToDeck(card, el);
                return;
            }
            
            const surfaceRect = readingSurface.getBoundingClientRect();
            let newPercentX = (el.offsetLeft / surfaceRect.width) * 100;
            let newPercentY = (el.offsetTop / surfaceRect.height) * 100;
            
            const nearestSlot = findNearestSlot(newPercentX, newPercentY);
            if (nearestSlot) {
                newPercentX = nearestSlot.position.percentX;
                newPercentY = nearestSlot.position.percentY;
            }
            
            el.style.left = newPercentX + '%';
            el.style.top = newPercentY + '%';
            el.dataset.percentX = newPercentX;
            el.dataset.percentY = newPercentY;
            
            updateSpreadSlotsFilled();
            saveCurrentReading();
        }
        
        // Click/tap action if quick and no movement
        const elapsed = Date.now() - mouseDownTime;
        if (elapsed < HOLD_THRESHOLD && !hasMoved) {
            if (!el.classList.contains('flipped') && !el.classList.contains('flipping')) {
                const willReverse = reversalsEnabled && Math.random() < 0.5;
                el.classList.add('flipping');
                if (willReverse) el.classList.add('will-reverse');
                
                setTimeout(() => {
                    el.classList.remove('flipping', 'will-reverse');
                    el.classList.add('flipped');
                    if (willReverse) el.classList.add('reversed');
                    saveCurrentReading();
                }, 600);
            } else if (el.classList.contains('flipped')) {
                // Add lifting effect before showing modal
                el.classList.add('lifting');
                setTimeout(() => {
                    showCardModal(card, el.classList.contains('reversed'), el);
                    // Remove lifting class after modal opens
                    setTimeout(() => {
                        el.classList.remove('lifting');
                    }, 100);
                }, 200);
            }
        }
    }
    
    // Mouse events
    el.addEventListener('mousedown', e => {
        e.preventDefault();
        initDrag(getEventCoords(e));
        
        const onMove = e => handleMove(getEventCoords(e));
        const onUp = e => {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            handleEnd(getEventCoords(e));
        };
        
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    });
    
    // Touch events
    el.addEventListener('touchstart', e => {
        initDrag(getEventCoords(e));
        
        const onMove = e => handleMove(getEventCoords(e));
        const onEnd = e => {
            document.removeEventListener('touchmove', onMove);
            document.removeEventListener('touchend', onEnd);
            const coords = e.changedTouches?.[0] ? { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY } : null;
            handleEnd(coords);
        };
        
        document.addEventListener('touchmove', onMove);
        document.addEventListener('touchend', onEnd);
    }, { passive: true });
}

function returnCardToDeck(card, element) {
    // Remove from placed cards
    placedCards = placedCards.filter(p => p.card.id !== card.id);
    element.remove();
    
    // Add back to deck
    deck.push(card);
    
    // Re-render deck to include returned card
    renderDeck();
    updateDevPanel();
    
    // Update spread slots filled state
    updateSpreadSlotsFilled();
    
    // Auto-save (or clear if no cards left)
    saveCurrentReading();
    
    // Show drag text if no cards left
    if (placedCards.length === 0) {
        readingSurface.classList.remove('has-cards');
    }
}

function showCardModal(card, isReversed = false, cardElement = null) {
    const modalCard = document.getElementById('modalCard');
    const modalPositionTitle = document.getElementById('modalPositionTitle');
    
    modalCard.innerHTML = getModalContent(card);
    if (isReversed) {
        modalCard.classList.add('reversed');
    } else {
        modalCard.classList.remove('reversed');
    }
    
    // Find spread position if applicable
    let positionName = null;
    let positionPrompt = null;
    if (cardElement && currentSpread) {
        const cardX = parseFloat(cardElement.dataset.percentX);
        const cardY = parseFloat(cardElement.dataset.percentY);
        const matchingPos = currentSpread.positions.find(pos => 
            Math.abs(cardX - pos.percentX) < 3 && Math.abs(cardY - pos.percentY) < 3
        );
        if (matchingPos) {
            positionName = matchingPos.name;
            positionPrompt = matchingPos.prompt;
        }
    }
    
    // Show position title and prompt if found
    if (positionName) {
        let positionHtml = `<span class="position-name">${positionName}</span>`;
        if (positionPrompt) {
            positionHtml += `<span class="position-prompt">${positionPrompt}</span>`;
        }
        modalPositionTitle.innerHTML = positionHtml;
        modalPositionTitle.style.display = 'block';
    } else {
        modalPositionTitle.style.display = 'none';
    }
    
    document.getElementById('modalTitle').textContent = card.name + (isReversed ? ' (Reversed)' : '');
    document.getElementById('modalSubtitle').textContent = card.arcana + ' Arcana' + (card.suit ? ' · ' + card.suit : '');
    
    // Populate meanings
    const meanings = TAROT_MEANINGS[card.id];
    if (meanings) {
        document.getElementById('keywordsUpright').textContent = meanings.keywords.upright.join(' · ');
        document.getElementById('keywordsReversed').textContent = meanings.keywords.reversed.join(' · ');
        document.getElementById('meaningText').textContent = isReversed ? meanings.reversed : meanings.upright;
        document.getElementById('modalMeanings').style.display = 'block';
        
        // Highlight active orientation
        document.querySelector('.keywords-upright').classList.toggle('active', !isReversed);
        document.querySelector('.keywords-reversed').classList.toggle('active', isReversed);
        
        // Reset meanings toggle state (collapsed by default)
        document.getElementById('meaningsToggle').classList.remove('expanded');
        document.getElementById('meaningsContent').classList.remove('expanded');
    } else {
        document.getElementById('modalMeanings').style.display = 'none';
    }
    
    cardModal.classList.add('active');
}

// Meanings toggle
document.getElementById('meaningsToggle').addEventListener('click', () => {
    document.getElementById('meaningsToggle').classList.toggle('expanded');
    document.getElementById('meaningsContent').classList.toggle('expanded');
});

modalClose.addEventListener('click', () => cardModal.classList.remove('active'));
cardModal.addEventListener('click', e => { if (e.target === cardModal) cardModal.classList.remove('active'); });

// Shuffle with swirl
shuffleBtn.addEventListener('click', () => {
    const cards = deckContainer.querySelectorAll('.card');
    if (cards.length === 0) return;
    shuffleBtn.disabled = true;

    // Phase 1: Scatter
    cards.forEach(card => {
        card.classList.add('shuffling');
        const rx = (Math.random() - 0.5) * 320;
        const ry = (Math.random() - 0.5) * 50;
        const rr = (Math.random() - 0.5) * 400;
        card.style.transform = `translate(-50%, -50%) translateX(${rx}px) translateY(${ry}px) rotate(${rr}deg)`;
        card.style.zIndex = Math.floor(Math.random() * 100);
    });

    // Phase 2: More chaos
    setTimeout(() => {
        cards.forEach(card => {
            const rx = (Math.random() - 0.5) * 280;
            const ry = (Math.random() - 0.5) * 40;
            const rr = (Math.random() - 0.5) * 300;
            card.style.transform = `translate(-50%, -50%) translateX(${rx}px) translateY(${ry}px) rotate(${rr}deg)`;
        });
    }, 300);

    // Phase 3: Shuffle data
    setTimeout(() => { deck = shuffleArray(deck); }, 600);

    // Phase 4: Settle
    setTimeout(() => {
        cards.forEach(card => {
            card.classList.remove('shuffling');
            card.classList.add('settling');
        });
        renderDeckAnimated();
        updateDevPanel();
    }, 800);

    // Cleanup
    setTimeout(() => {
        deckContainer.querySelectorAll('.card').forEach(c => c.classList.remove('settling'));
        shuffleBtn.disabled = false;
    }, 1500);
});

function renderDeckAnimated() {
    const { cardW, overlap } = getCardDimensions();
    const cardMap = {};
    deckContainer.querySelectorAll('.card').forEach(c => { cardMap[c.dataset.cardId] = c; });

    applyDeckLayout(deck, cardW, overlap, (card, index, pos) => {
        const el = cardMap[card.id];
        if (el) {
            el.style.top = pos.top;
            el.style.transform = `translate(-50%, -50%) translateX(${pos.xPos}px)${pos.arcY ? ` translateY(${pos.arcY}px)` : ''}${pos.rotation ? ` rotate(${pos.rotation}deg)` : ''}`;
            el.style.setProperty('--base-x', `${pos.xPos}px`);
            if (pos.arcY) el.style.setProperty('--base-y', `${pos.arcY}px`);
            if (pos.rotation) el.style.setProperty('--base-rot', `${pos.rotation}deg`);
            el.style.zIndex = index;
            el.dataset.index = index;
        }
    });
}

// Reset
resetBtn.addEventListener('click', () => {
    // Clear placed cards and text boxes but keep Aa button
    placedCards.forEach(p => p.element.remove());
    textBoxes.forEach(tb => tb.element.remove());
    placedCards = [];
    textBoxes = [];
    textBoxIdCounter = 0;
    readingSurface.classList.remove('has-cards');
    document.querySelector('.deck-area').classList.remove('docked');
    currentReadingId = null;
    
    // Clear spread
    currentSpread = null;
    clearSpreadSlots();
    hideSpreadReference();
    
    // Reset zoom/pan
    resetZoom();
    
    localStorage.removeItem(STORAGE_KEYS.CURRENT_READING);
    initializeDeck();
});

// Reversals toggle
reversalsToggle.addEventListener('click', () => {
    reversalsToggle.classList.toggle('active');
    reversalsEnabled = reversalsToggle.classList.contains('active');
    savePreferences();
});

// Dev toggle
devToggle.addEventListener('click', () => {
    devToggle.classList.toggle('active');
    document.body.classList.toggle('dev-mode', devToggle.classList.contains('active'));
    savePreferences();
});

// Theme toggle
function updateThemeIcon(isDark) {
    const icon = document.getElementById('themeIcon');
    if (isDark) {
        icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />';
    } else {
        icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />';
    }
}

themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark');
    updateThemeIcon(document.body.classList.contains('dark'));
    savePreferences();
});

// Dev panel
function updateDevPanel() {
    const all = [...deck, ...placedCards.map(p => p.card)];
    const ids = all.map(c => c.id);
    const counts = {};
    ids.forEach(id => { counts[id] = (counts[id] || 0) + 1; });

    devInfo.innerHTML = all.map(c => `<span class="${counts[c.id] > 1 ? 'duplicate' : ''}">${c.id}</span>`).join('');

    const hasDupes = Object.values(counts).some(c => c > 1);
    const unique = new Set(ids).size;

    if (!hasDupes && all.length === 78 && unique === 78) {
        validationStatus.className = 'validation-status valid';
        validationStatus.textContent = `✓ Valid: 78 unique cards (${deck.length} deck, ${placedCards.length} placed)`;
    } else {
        validationStatus.className = 'validation-status invalid';
        validationStatus.textContent = `✗ Invalid: ${unique} unique, ${all.length} total`;
    }
}

// Re-render deck on window resize (debounced)
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        if (deck.length > 0) {
            renderDeck();
        }
    }, 150);
});

// Init
// ============================================
// TEXT TOOL
// ============================================

let textModeActive = false;
let textBoxes = [];
let textBoxIdCounter = 0;
let activeTextBox = null;

function toggleTextMode() {
    textModeActive = !textModeActive;
    if (textToolBtn) textToolBtn.classList.toggle('active', textModeActive);
    readingSurface.classList.toggle('text-mode', textModeActive);
    
    if (!textModeActive) {
        // Deselect active text box
        if (activeTextBox) {
            deactivateTextBox(activeTextBox);
        }
    }
}

function exitTextMode() {
    if (textModeActive) {
        textModeActive = false;
        if (textToolBtn) textToolBtn.classList.remove('active');
        readingSurface.classList.remove('text-mode');
        readingSurface.classList.remove('text-mode-drawing');
        if (activeTextBox) {
            deactivateTextBox(activeTextBox);
        }
    }
}

function createTextBox(x, y, width = null, height = null, showBorder = false, initialContent = '', initialFontSize = 13, usePercent = false) {
    const id = ++textBoxIdCounter;
    const box = document.createElement('div');
    box.className = 'text-box';
    box.id = `text-box-${id}`;
    box.dataset.textBoxId = id;
    
    // Convert to percentages if not already
    const surfaceRect = readingSurface.getBoundingClientRect();
    let percentX, percentY;
    if (usePercent) {
        percentX = x;
        percentY = y;
    } else {
        percentX = (x / surfaceRect.width) * 100;
        percentY = (y / surfaceRect.height) * 100;
    }
    
    box.style.left = percentX + '%';
    box.style.top = percentY + '%';
    box.dataset.percentX = percentX;
    box.dataset.percentY = percentY;
    
    if (width && height) {
        box.style.width = width + 'px';
        box.style.height = height + 'px';
        box.classList.add('show-border');
    }
    
    box.innerHTML = `
        <div class="text-box-border"></div>
        <textarea class="text-box-content" placeholder="Start typing..." spellcheck="false">${initialContent}</textarea>
        <div class="text-box-controls">
            <button class="text-box-font-btn" data-action="increase">+</button>
            <span class="text-box-font-label">Aa</span>
            <button class="text-box-font-btn" data-action="decrease">−</button>
        </div>
        <div class="text-box-handle nw"></div>
        <div class="text-box-handle n"></div>
        <div class="text-box-handle ne"></div>
        <div class="text-box-handle e"></div>
        <div class="text-box-handle se"></div>
        <div class="text-box-handle s"></div>
        <div class="text-box-handle sw"></div>
        <div class="text-box-handle w"></div>
    `;
    
    const textarea = box.querySelector('.text-box-content');
    const fontBtns = box.querySelectorAll('.text-box-font-btn');
    const handles = box.querySelectorAll('.text-box-handle');
    
    // Auto-resize textarea height
    function autoResizeTextarea() {
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
        box.style.height = 'auto';
    }
    
    let fontSize = initialFontSize;
    textarea.style.fontSize = fontSize + 'px';
    const minFontSize = 10;
    const maxFontSize = 24;
    
    // Font size controls
    fontBtns.forEach(btn => {
        btn.addEventListener('mousedown', e => e.stopPropagation());
        btn.addEventListener('click', e => {
            e.stopPropagation();
            const action = btn.dataset.action;
            if (action === 'increase' && fontSize < maxFontSize) {
                fontSize += 2;
            } else if (action === 'decrease' && fontSize > minFontSize) {
                fontSize -= 2;
            }
            textarea.style.fontSize = fontSize + 'px';
            // Update stored fontSize
            const tbData = textBoxes.find(tb => tb.element === box);
            if (tbData) tbData.fontSize = fontSize;
            saveCurrentReading();
        });
    });
    
    // Focus/blur handling
    textarea.addEventListener('focus', () => {
        activateTextBox(box);
    });
    
    textarea.addEventListener('blur', e => {
        // Small delay to allow click on controls
        setTimeout(() => {
            if (!box.contains(document.activeElement)) {
                // If empty (including just spaces), remove the box
                if (!textarea.value.trim()) {
                    removeTextBox(box);
                } else {
                    deactivateTextBox(box);
                    saveCurrentReading();
                }
            }
        }, 150);
    });
    
    // Save on input
    textarea.addEventListener('input', () => {
        autoResizeTextarea();
        saveCurrentReading();
    });
    
    // Initial auto-resize
    if (initialContent) {
        setTimeout(autoResizeTextarea, 0);
    }
    
    // Drag handling - on the box itself (padding area), not textarea
    let isDraggingBox = false;
    let dragStartX, dragStartY, boxStartPercentX, boxStartPercentY;
    
    box.addEventListener('mousedown', e => {
        // If clicking directly on the box (padding area), start drag
        // If clicking on textarea, controls, or handles, don't drag
        if (e.target === box) {
            e.preventDefault();
            e.stopPropagation();
            isDraggingBox = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            boxStartPercentX = parseFloat(box.dataset.percentX);
            boxStartPercentY = parseFloat(box.dataset.percentY);
            box.style.zIndex = 70;
            box.classList.add('dragging');
            
            document.addEventListener('mousemove', onDragBox);
            document.addEventListener('mouseup', onDragBoxEnd);
        }
    });
    
    function onDragBox(e) {
        if (!isDraggingBox) return;
        const surfaceRect = readingSurface.getBoundingClientRect();
        // Convert pixel delta to percentage delta, accounting for zoom
        const dx = ((e.clientX - dragStartX) / currentZoom / surfaceRect.width) * 100;
        const dy = ((e.clientY - dragStartY) / currentZoom / surfaceRect.height) * 100;
        const newPercentX = boxStartPercentX + dx;
        const newPercentY = boxStartPercentY + dy;
        box.style.left = newPercentX + '%';
        box.style.top = newPercentY + '%';
        box.dataset.percentX = newPercentX;
        box.dataset.percentY = newPercentY;
    }
    
    function onDragBoxEnd() {
        isDraggingBox = false;
        box.style.zIndex = 55;
        box.classList.remove('dragging');
        document.removeEventListener('mousemove', onDragBox);
        document.removeEventListener('mouseup', onDragBoxEnd);
        saveCurrentReading();
    }
    
    // Click on textarea focuses it
    textarea.addEventListener('mousedown', e => {
        e.stopPropagation();
        activateTextBox(box);
    });
    
    // Resize handles
    handles.forEach(handle => {
        handle.addEventListener('mousedown', e => {
            e.stopPropagation();
            e.preventDefault();
            startResize(box, handle, e);
        });
    });
    
    readingSurfaceContent.appendChild(box);
    textBoxes.push({ id, element: box, fontSize });
    
    // Auto-focus only if not restoring
    if (!initialContent) {
        textarea.focus();
        activateTextBox(box);
    }
    
    return box;
}

function restoreTextBox(savedBox) {
    const surfaceRect = readingSurface.getBoundingClientRect();
    
    let x, y, width, height, usePercent;
    
    if (savedBox.percentX !== undefined) {
        // Use percentages directly
        x = savedBox.percentX;
        y = savedBox.percentY;
        width = savedBox.percentW ? (savedBox.percentW / 100) * surfaceRect.width : null;
        height = savedBox.percentH ? (savedBox.percentH / 100) * surfaceRect.height : null;
        usePercent = true;
    } else {
        // Legacy support for pixel values
        x = savedBox.left;
        y = savedBox.top;
        width = savedBox.width;
        height = savedBox.height;
        usePercent = false;
    }
    
    const box = createTextBox(
        x,
        y,
        width,
        height,
        savedBox.showBorder,
        savedBox.content || '',
        savedBox.fontSize || 13,
        usePercent
    );
    
    if (savedBox.showBorder) {
        box.classList.add('show-border');
    }
    
    // Don't focus restored boxes
    const textarea = box.querySelector('.text-box-content');
    textarea.blur();
    deactivateTextBox(box);
    
    return box;
}

function activateTextBox(box) {
    if (activeTextBox && activeTextBox !== box) {
        deactivateTextBox(activeTextBox);
    }
    activeTextBox = box;
    box.classList.add('editing');
}

function deactivateTextBox(box) {
    box.classList.remove('editing');
    if (activeTextBox === box) {
        activeTextBox = null;
    }
}

function removeTextBox(box) {
    box.remove();
    textBoxes = textBoxes.filter(tb => tb.element !== box);
    if (activeTextBox === box) {
        activeTextBox = null;
    }
}

// Resize functionality
let resizeState = null;

function startResize(box, handle, e) {
    const rect = box.getBoundingClientRect();
    const surfaceRect = readingSurface.getBoundingClientRect();
    
    resizeState = {
        box,
        handle: handle.className.split(' ').find(c => c !== 'text-box-handle'),
        startX: e.clientX,
        startY: e.clientY,
        startPercentX: parseFloat(box.dataset.percentX),
        startPercentY: parseFloat(box.dataset.percentY),
        startWidth: rect.width,
        startHeight: rect.height,
        surfaceWidth: surfaceRect.width,
        surfaceHeight: surfaceRect.height
    };
    
    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', endResize);
}

function doResize(e) {
    if (!resizeState) return;
    
    const { box, handle, startX, startY, startPercentX, startPercentY, startWidth, startHeight, surfaceWidth, surfaceHeight } = resizeState;
    const dx = (e.clientX - startX) / currentZoom;
    const dy = (e.clientY - startY) / currentZoom;
    
    let newPercentX = startPercentX;
    let newPercentY = startPercentY;
    let newWidth = startWidth;
    let newHeight = startHeight;
    
    // Handle horizontal resize
    if (handle.includes('w')) {
        newWidth = Math.max(50, startWidth - dx);
        newPercentX = startPercentX + ((startWidth - newWidth) / surfaceWidth) * 100;
    } else if (handle.includes('e')) {
        newWidth = Math.max(50, startWidth + dx);
    }
    
    // Handle vertical resize
    if (handle.includes('n')) {
        newHeight = Math.max(30, startHeight - dy);
        newPercentY = startPercentY + ((startHeight - newHeight) / surfaceHeight) * 100;
    } else if (handle.includes('s')) {
        newHeight = Math.max(30, startHeight + dy);
    }
    
    box.style.left = newPercentX + '%';
    box.style.top = newPercentY + '%';
    box.dataset.percentX = newPercentX;
    box.dataset.percentY = newPercentY;
    box.style.width = newWidth + 'px';
    
    // Only set fixed height if vertically resizing, otherwise auto-fit to content
    if (handle.includes('n') || handle.includes('s')) {
        box.style.height = newHeight + 'px';
    } else {
        // Auto-fit height to text content when only changing width
        const textarea = box.querySelector('.text-box-content');
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
        box.style.height = 'auto';
    }
    box.classList.add('show-border');
}

function endResize() {
    if (resizeState) {
        const box = resizeState.box;
        const handle = resizeState.handle;
        // If was horizontal-only resize, ensure height stays auto-fit
        if (!handle.includes('n') && !handle.includes('s')) {
            const textarea = box.querySelector('.text-box-content');
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
            box.style.height = 'auto';
        }
    }
    resizeState = null;
    document.removeEventListener('mousemove', doResize);
    document.removeEventListener('mouseup', endResize);
    saveCurrentReading();
}

// Text tool button - use event delegation since button may be recreated
document.addEventListener('click', e => {
    const btn = e.target.closest('.text-tool-btn');
    if (btn) {
        e.stopPropagation();
        toggleTextMode();
    }
});

// Reading surface click/drag for text mode
let textDrawState = null;

readingSurface.addEventListener('mousedown', e => {
    if (!textModeActive) return;
    
    // Ignore if clicking on a card, text box, or button
    if (e.target.closest('.placed-card') || 
        e.target.closest('.text-box') || 
        e.target.closest('.text-tool-btn')) {
        return;
    }
    
    const rect = readingSurface.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    textDrawState = {
        startX: x,
        startY: y,
        isDragging: false,
        previewBox: null
    };
    
    document.addEventListener('mousemove', onTextDraw);
    document.addEventListener('mouseup', onTextDrawEnd);
});

function onTextDraw(e) {
    if (!textDrawState) return;
    
    const rect = readingSurface.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const dx = Math.abs(x - textDrawState.startX);
    const dy = Math.abs(y - textDrawState.startY);
    
    // Start dragging if moved more than 5px
    if (dx > 5 || dy > 5) {
        textDrawState.isDragging = true;
        readingSurface.classList.add('text-mode-drawing');
        readingSurface.classList.remove('text-mode');
        
        // Create or update preview box
        if (!textDrawState.previewBox) {
            textDrawState.previewBox = document.createElement('div');
            textDrawState.previewBox.className = 'text-box show-border';
            textDrawState.previewBox.style.pointerEvents = 'none';
            textDrawState.previewBox.style.opacity = '0.6';
            textDrawState.previewBox.innerHTML = '<div class="text-box-border" style="opacity:1"></div>';
            readingSurfaceContent.appendChild(textDrawState.previewBox);
        }
        
        const left = Math.min(textDrawState.startX, x);
        const top = Math.min(textDrawState.startY, y);
        const width = Math.abs(x - textDrawState.startX);
        const height = Math.abs(y - textDrawState.startY);
        
        textDrawState.previewBox.style.left = left + 'px';
        textDrawState.previewBox.style.top = top + 'px';
        textDrawState.previewBox.style.width = width + 'px';
        textDrawState.previewBox.style.height = height + 'px';
    }
}

function onTextDrawEnd(e) {
    document.removeEventListener('mousemove', onTextDraw);
    document.removeEventListener('mouseup', onTextDrawEnd);
    
    if (!textDrawState) return;
    
    readingSurface.classList.remove('text-mode-drawing');
    readingSurface.classList.add('text-mode');
    
    // Remove preview box
    if (textDrawState.previewBox) {
        textDrawState.previewBox.remove();
    }
    
    if (textDrawState.isDragging) {
        // Create text box with dragged dimensions
        const rect = readingSurface.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const left = Math.min(textDrawState.startX, x);
        const top = Math.min(textDrawState.startY, y);
        const width = Math.max(50, Math.abs(x - textDrawState.startX));
        const height = Math.max(30, Math.abs(y - textDrawState.startY));
        
        createTextBox(left, top, width, height, true);
    } else {
        // Single click - create borderless text box
        createTextBox(textDrawState.startX, textDrawState.startY);
    }
    
    textDrawState = null;
}

// Exit text mode when clicking on a card
readingSurface.addEventListener('click', e => {
    if (e.target.closest('.placed-card')) {
        exitTextMode();
    }
});

// Exit text mode with Escape key
document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && textModeActive) {
        exitTextMode();
    }
});

// ============================================
// ZOOM FUNCTIONALITY
// ============================================

let currentZoom = 1;
let panX = 0;
let panY = 0;
let isPanning = false;
let panStartX, panStartY, panStartPanX, panStartPanY;
const MIN_ZOOM = 0.5;
const MAX_ZOOM = 3;
const ZOOM_STEP = 0.15;

const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const readingSurfaceContent = document.getElementById('readingSurfaceContent');

function updateTransform() {
    readingSurfaceContent.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
    
    // Update button states
    zoomInBtn.disabled = currentZoom >= MAX_ZOOM;
    zoomOutBtn.disabled = currentZoom <= MIN_ZOOM;
}

function setZoom(level, centerX = null, centerY = null) {
    const oldZoom = currentZoom;
    currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, level));
    
    // If center point provided, adjust pan to zoom toward that point
    if (centerX !== null && centerY !== null) {
        const surfaceRect = readingSurface.getBoundingClientRect();
        const contentCenterX = surfaceRect.width / 2;
        const contentCenterY = surfaceRect.height / 2;
        
        // Calculate the point relative to content center
        const pointX = centerX - contentCenterX - panX;
        const pointY = centerY - contentCenterY - panY;
        
        // Scale the pan offset
        const zoomRatio = currentZoom / oldZoom;
        panX = panX - pointX * (zoomRatio - 1);
        panY = panY - pointY * (zoomRatio - 1);
    }
    
    updateTransform();
}

function zoomIn(centerX = null, centerY = null) {
    setZoom(currentZoom + ZOOM_STEP, centerX, centerY);
}

function zoomOut(centerX = null, centerY = null) {
    setZoom(currentZoom - ZOOM_STEP, centerX, centerY);
}

function resetZoom() {
    currentZoom = 1;
    panX = 0;
    panY = 0;
    updateTransform();
}

zoomInBtn.addEventListener('click', e => {
    e.stopPropagation();
    zoomIn();
});

zoomOutBtn.addEventListener('click', e => {
    e.stopPropagation();
    zoomOut();
});

// Cmd/Ctrl + scroll to zoom at cursor position
readingSurface.addEventListener('wheel', e => {
    if (e.metaKey || e.ctrlKey) {
        e.preventDefault();
        const rect = readingSurface.getBoundingClientRect();
        const cursorX = e.clientX - rect.left;
        const cursorY = e.clientY - rect.top;
        
        if (e.deltaY < 0) {
            zoomIn(cursorX, cursorY);
        } else {
            zoomOut(cursorX, cursorY);
        }
    } else {
        // Normal scroll - pan vertically
        e.preventDefault();
        panY -= e.deltaY * 0.5;
        panX -= e.deltaX * 0.5;
        updateTransform();
    }
}, { passive: false });

// Space + drag to pan
document.addEventListener('keydown', e => {
    if (e.code === 'Space' && !e.target.matches('input, textarea')) {
        e.preventDefault();
        readingSurface.style.cursor = 'grab';
    }
});

document.addEventListener('keyup', e => {
    if (e.code === 'Space') {
        readingSurface.style.cursor = '';
        if (isPanning) {
            isPanning = false;
            readingSurface.style.cursor = '';
        }
    }
});

readingSurface.addEventListener('mousedown', e => {
    // Check if space is held
    if (e.buttons === 1 && readingSurface.style.cursor === 'grab') {
        e.preventDefault();
        isPanning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        panStartPanX = panX;
        panStartPanY = panY;
        readingSurface.style.cursor = 'grabbing';
    }
});

document.addEventListener('mousemove', e => {
    if (isPanning) {
        panX = panStartPanX + (e.clientX - panStartX);
        panY = panStartPanY + (e.clientY - panStartY);
        updateTransform();
    }
});

document.addEventListener('mouseup', e => {
    if (isPanning) {
        isPanning = false;
        readingSurface.style.cursor = 'grab';
    }
});

// Arrow keys to pan
document.addEventListener('keydown', e => {
    if (e.target.matches('input, textarea')) return;
    
    const panAmount = 30;
    switch (e.key) {
        case 'ArrowUp':
            e.preventDefault();
            panY += panAmount;
            updateTransform();
            break;
        case 'ArrowDown':
            e.preventDefault();
            panY -= panAmount;
            updateTransform();
            break;
        case 'ArrowLeft':
            e.preventDefault();
            panX += panAmount;
            updateTransform();
            break;
        case 'ArrowRight':
            e.preventDefault();
            panX -= panAmount;
            updateTransform();
            break;
        case '0':
            if (e.metaKey || e.ctrlKey) {
                e.preventDefault();
                resetZoom();
            }
            break;
    }
});

// ============================================
// MOBILE TAP-TO-PLACE (for staged cards)
// ============================================

readingSurface.addEventListener('touchstart', e => {
    // Only handle if there's a staged card waiting to be placed
    if (!stagedCard) return;
    
    // Ignore if touching a placed card or text box
    if (e.target.closest('.placed-card') || e.target.closest('.text-box')) {
        return;
    }
    
    e.preventDefault();
    const touch = e.touches[0];
    
    // Get position relative to reading surface content (accounting for zoom/pan)
    const surfaceRect = readingSurfaceContent.getBoundingClientRect();
    const x = (touch.clientX - surfaceRect.left) / currentZoom;
    const y = (touch.clientY - surfaceRect.top) / currentZoom;
    
    // Convert to percentages
    const percentX = (x / readingSurfaceContent.offsetWidth) * 100;
    const percentY = (y / readingSurfaceContent.offsetHeight) * 100;
    
    // Place the staged card
    placeStagedCard(percentX, percentY);
}, { passive: false });

function placeStagedCard(percentX, percentY) {
    if (!stagedCard) return;
    
    // Get the card data
    const cardId = stagedCard.dataset.cardId;
    const cardIndex = parseInt(stagedCard.dataset.index);
    const card = deck.find(c => c.id === cardId);
    
    if (!card) {
        cancelStagedCard();
        return;
    }
    
    triggerHaptic('medium');
    
    // Remove from deck
    deck.splice(cardIndex, 1);
    
    // Clean up staged card element
    stagedCard.classList.remove('card-staged');
    stagedCard.remove();
    stagedCard = null;
    
    // Restore opacity of remaining deck cards
    const cards = deckContainer.querySelectorAll('.card');
    cards.forEach(card => {
        card.style.opacity = '';
    });
    
    // Check for reversals
    const willReverse = reversalsEnabled && Math.random() < 0.3;
    
    // Create placed card
    const placedCard = document.createElement('div');
    placedCard.className = 'placed-card';
    placedCard.dataset.cardId = card.id;
    placedCard.dataset.percentX = percentX;
    placedCard.dataset.percentY = percentY;
    placedCard.innerHTML = `
        <div class="card-face card-back"></div>
        <div class="card-face card-front">${getCardFrontContent(card)}</div>
    `;
    placedCard.style.left = percentX + '%';
    placedCard.style.top = percentY + '%';
    
    // Find nearest slot if there's a spread active
    const nearestSlot = findNearestSlot(percentX, percentY);
    if (nearestSlot) {
        placedCard.style.left = nearestSlot.percentX + '%';
        placedCard.style.top = nearestSlot.percentY + '%';
        placedCard.dataset.percentX = nearestSlot.percentX;
        placedCard.dataset.percentY = nearestSlot.percentY;
    }
    
    readingSurfaceContent.appendChild(placedCard);
    placedCards.push({ card, element: placedCard, isReversed: willReverse });
    
    // Add handlers for the placed card
    addPlacedCardHandlers(placedCard, card, willReverse);
    
    // Update UI
    readingSurface.classList.add('has-cards');
    updateSpreadSlotsFilled();
    dockDeck();
    renderDeck();
    saveCurrentReading();
}

// ============================================
// SPREAD TEMPLATES
// ============================================

const SPREADS = {
    single: {
        id: 'single',
        name: 'Single Card',
        description: 'A simple one-card draw for quick insight or daily guidance.',
        positions: [
            { id: 1, name: '', percentX: 50, percentY: 45, prompt: 'The central message or energy for your question' }
        ]
    },
    threeCard: {
        id: 'threeCard',
        name: 'Three Card',
        description: 'Past, Present, and Future. A versatile spread for understanding the flow of a situation.',
        positions: [
            { id: 1, name: 'Past', percentX: 35, percentY: 45, prompt: 'Past influences and foundations that led to this moment' },
            { id: 2, name: 'Present', percentX: 50, percentY: 45, prompt: 'Current situation, energies, and challenges' },
            { id: 3, name: 'Future', percentX: 65, percentY: 45, prompt: 'Likely outcome if current path continues' }
        ]
    },
    spirit: {
        id: 'spirit',
        name: 'The Spirit Spread',
        description: 'A five-card elemental cross. Earth (North), Air (East), Fire (South), Water (West), and Spirit at center.',
        positions: [
            { id: 1, name: 'Earth', percentX: 50, percentY: 15, prompt: 'Physical and material aspects: health, wealth, property' },
            { id: 2, name: 'Air', percentX: 65, percentY: 45, prompt: 'Mental aspects: communication, thoughts, intellect' },
            { id: 3, name: 'Fire', percentX: 50, percentY: 75, prompt: 'Passion and will: strength, drive, power to change' },
            { id: 4, name: 'Water', percentX: 35, percentY: 45, prompt: 'Emotional aspects: feelings, intuition, relationships' },
            { id: 5, name: 'Spirit', percentX: 50, percentY: 45, prompt: 'Archetypal overview: the soul of the matter, future trajectory' }
        ]
    },
    treeOfLife: {
        id: 'treeOfLife',
        name: 'Tree of Life',
        description: 'Rachel Mann\'s Practical Tree of Life via Mary K. Greer. Work down the pillars (1-6), then up the middle (7-10). Da\'at (11) bridges knowledge.',
        positions: [
            { id: 10, name: 'Spirit', percentX: 50, percentY: 5, prompt: 'The divine or higher purpose guiding the situation' },
            { id: 2, name: 'Form', percentX: 30, percentY: 20, prompt: 'The structure or form the issue takes' },
            { id: 1, name: 'Force', percentX: 70, percentY: 20, prompt: 'The generative, active energy behind the issue' },
            { id: 11, name: 'Da\'at', percentX: 50, percentY: 35, prompt: 'Hidden knowledge bridging understanding' },
            { id: 4, name: 'Against', percentX: 30, percentY: 50, prompt: 'Forces or factors working against you' },
            { id: 3, name: 'For', percentX: 70, percentY: 50, prompt: 'Forces or factors working in your favor' },
            { id: 9, name: 'Advice', percentX: 50, percentY: 65, prompt: 'Guidance or recommended action' },
            { id: 6, name: 'Thoughts', percentX: 30, percentY: 80, prompt: 'Mental aspects and thought patterns' },
            { id: 5, name: 'Feelings', percentX: 70, percentY: 80, prompt: 'Emotional aspects and feelings involved' },
            { id: 8, name: 'Persona', percentX: 50, percentY: 95, prompt: 'How you present yourself or are perceived' },
            { id: 7, name: 'World', percentX: 50, percentY: 125, prompt: 'Material world and practical manifestation' }
        ]
    }
};

// Spread state
let currentSpread = null;
let spreadSlots = [];

// Helper: Check if a spread position has a card placed on it
function isSlotFilledByCard(pos) {
    return placedCards.some(p => {
        const cardX = parseFloat(p.element.dataset.percentX);
        const cardY = parseFloat(p.element.dataset.percentY);
        return Math.abs(cardX - pos.percentX) < 3 && Math.abs(cardY - pos.percentY) < 3;
    });
}

// DOM elements
const spreadBtn = document.getElementById('spreadBtn');
const spreadPanel = document.getElementById('spreadPanel');
const spreadOverlay = document.getElementById('spreadOverlay');
const spreadPanelClose = document.getElementById('spreadPanelClose');
const spreadList = document.getElementById('spreadList');
const clearSpreadBtn = document.getElementById('clearSpreadBtn');

function openSpreadPanel() {
    renderSpreadList();
    spreadPanel.classList.add('active');
    spreadOverlay.classList.add('active');
}

function closeSpreadPanel() {
    spreadPanel.classList.remove('active');
    spreadOverlay.classList.remove('active');
}

function renderSpreadList() {
    spreadList.innerHTML = Object.values(SPREADS).map(spread => {
        const isActive = currentSpread && currentSpread.id === spread.id;
        const previewSlots = spread.positions.slice(0, 5).map(() => 
            '<div class="spread-preview-slot"></div>'
        ).join('');
        const moreCount = spread.positions.length > 5 ? `+${spread.positions.length - 5}` : '';
        
        return `
            <div class="spread-item ${isActive ? 'active' : ''}" data-spread-id="${spread.id}">
                <div class="spread-item-header">
                    <span class="spread-item-name">${spread.name}</span>
                    <span class="spread-item-count">${spread.positions.length} cards</span>
                </div>
                <p class="spread-item-desc">${spread.description}</p>
                <div class="spread-item-preview">${previewSlots}${moreCount ? `<span style="font-size:0.625rem;color:hsl(var(--muted-foreground))">${moreCount}</span>` : ''}</div>
            </div>
        `;
    }).join('');
}

function selectSpread(spreadId) {
    const spread = SPREADS[spreadId];
    if (!spread) return;
    
    currentSpread = spread;
    renderSpreadSlots();
    closeSpreadPanel();
    saveCurrentReading();
}

function clearSpread() {
    currentSpread = null;
    clearSpreadSlots();
    hideSpreadReference();
    closeSpreadPanel();
    saveCurrentReading();
}

function renderSpreadSlots() {
    clearSpreadSlots();
    if (!currentSpread) {
        hideSpreadReference();
        return;
    }
    
    // Get placed card dimensions by creating a temp element
    const tempCard = document.createElement('div');
    tempCard.className = 'placed-card';
    tempCard.style.visibility = 'hidden';
    tempCard.style.position = 'absolute';
    document.body.appendChild(tempCard);
    const computedStyle = getComputedStyle(tempCard);
    const cardW = parseFloat(computedStyle.width) || 120;
    const cardH = parseFloat(computedStyle.height) || 192;
    document.body.removeChild(tempCard);
    
    currentSpread.positions.forEach(pos => {
        const slot = document.createElement('div');
        slot.className = 'spread-slot';
        slot.dataset.slotId = pos.id;
        slot.dataset.slotName = pos.name;
        slot.dataset.slotPrompt = pos.prompt || '';
        slot.style.left = pos.percentX + '%';
        slot.style.top = pos.percentY + '%';
        slot.style.width = cardW + 'px';
        slot.style.height = cardH + 'px';
        
        // Only show label if name exists
        if (pos.name) {
            const label = document.createElement('span');
            label.className = 'spread-slot-label';
            label.textContent = pos.name;
            if (pos.prompt) {
                label.setAttribute('title', pos.prompt);
            }
            slot.appendChild(label);
        }
        
        // Check if slot is already filled
        if (isSlotFilledByCard(pos)) {
            slot.classList.add('filled');
        }
        
        readingSurfaceContent.appendChild(slot);
        spreadSlots.push({ position: pos, element: slot });
    });
    
    // Show and render reference panel
    showSpreadReference();
    
    // Auto-zoom to fit spread
    autoZoomToFitSpread();
}

function autoZoomToFitSpread() {
    if (!currentSpread) {
        resetZoom();
        return;
    }
    
    const positions = currentSpread.positions;
    
    // Get bounds of all positions
    const minX = Math.min(...positions.map(p => p.percentX));
    const maxX = Math.max(...positions.map(p => p.percentX));
    const minY = Math.min(...positions.map(p => p.percentY));
    const maxY = Math.max(...positions.map(p => p.percentY));
    
    // Get card size relative to surface (approximate)
    const surfaceRect = readingSurface.getBoundingClientRect();
    const tempCard = document.createElement('div');
    tempCard.className = 'placed-card';
    tempCard.style.visibility = 'hidden';
    tempCard.style.position = 'absolute';
    document.body.appendChild(tempCard);
    const cardStyle = getComputedStyle(tempCard);
    const cardW = parseFloat(cardStyle.width) || 120;
    const cardH = parseFloat(cardStyle.height) || 192;
    document.body.removeChild(tempCard);
    
    // Card dimensions as percentage of surface
    const cardWPercent = (cardW / surfaceRect.width) * 100;
    const cardHPercent = (cardH / surfaceRect.height) * 100;
    
    // Add padding for cards and labels (half card size + some margin)
    const padX = cardWPercent / 2 + 5;
    const padY = cardHPercent / 2 + 8; // Extra for label above
    
    // Calculate spread bounds including card sizes
    const spreadWidth = (maxX - minX) + cardWPercent + padX * 2;
    const spreadHeight = (maxY - minY) + cardHPercent + padY * 2;
    
    // Calculate zoom to fit
    const zoomX = 100 / spreadWidth;
    const zoomY = 100 / spreadHeight;
    let targetZoom = Math.min(zoomX, zoomY, MAX_ZOOM);
    targetZoom = Math.max(targetZoom, MIN_ZOOM);
    
    // Calculate pan to center the spread
    const spreadCenterX = (minX + maxX) / 2;
    const spreadCenterY = (minY + maxY) / 2;
    
    // Pan offset (in pixels) to center the spread
    const offsetX = (50 - spreadCenterX) * surfaceRect.width / 100 * targetZoom;
    const offsetY = (50 - spreadCenterY) * surfaceRect.height / 100 * targetZoom;
    
    // Apply zoom and pan
    currentZoom = targetZoom;
    panX = offsetX;
    panY = offsetY;
    updateTransform();
}

// Spread Reference Panel
const spreadReference = document.getElementById('spreadReference');
const spreadRefHeader = document.getElementById('spreadRefHeader');
const spreadRefTitle = document.getElementById('spreadRefTitle');
const spreadRefContent = document.getElementById('spreadRefContent');
const spreadRefClose = document.getElementById('spreadRefClose');

function showSpreadReference() {
    if (!currentSpread) return;
    
    spreadRefTitle.textContent = currentSpread.name;
    spreadReference.classList.add('active');
    renderSpreadReferenceCards();
}

function hideSpreadReference() {
    spreadReference.classList.remove('active');
}

function renderSpreadReferenceCards() {
    if (!currentSpread) return;
    
    // Calculate bounds of spread positions
    const positions = currentSpread.positions;
    const minX = Math.min(...positions.map(p => p.percentX));
    const maxX = Math.max(...positions.map(p => p.percentX));
    const minY = Math.min(...positions.map(p => p.percentY));
    const maxY = Math.max(...positions.map(p => p.percentY));
    
    // Add padding
    const padX = 15;
    const padY = 10;
    const rangeX = (maxX - minX) + padX * 2;
    const rangeY = (maxY - minY) + padY * 2;
    
    spreadRefContent.innerHTML = positions.map(pos => {
        // Normalize positions to fit in reference panel
        const normX = ((pos.percentX - minX + padX) / rangeX) * 100;
        const normY = ((pos.percentY - minY + padY) / rangeY) * 100;
        
        // Check if filled
        const isFilled = isSlotFilledByCard(pos);
        
        return `<div class="spread-ref-card ${isFilled ? 'filled' : ''}" 
                     style="left: ${normX}%; top: ${normY}%"
                     data-slot-id="${pos.id}"
                     title="${pos.name}">${pos.id}</div>`;
    }).join('');
}

function updateSpreadReference() {
    if (!currentSpread || !spreadReference.classList.contains('active')) return;
    renderSpreadReferenceCards();
}

// Make reference panel draggable
let isRefDragging = false;
let refDragStartX, refDragStartY, refStartLeft, refStartTop;

spreadRefHeader.addEventListener('mousedown', e => {
    if (e.target === spreadRefClose) return;
    isRefDragging = true;
    refDragStartX = e.clientX;
    refDragStartY = e.clientY;
    refStartLeft = spreadReference.offsetLeft;
    refStartTop = spreadReference.offsetTop;
    e.preventDefault();
});

document.addEventListener('mousemove', e => {
    if (!isRefDragging) return;
    const dx = e.clientX - refDragStartX;
    const dy = e.clientY - refDragStartY;
    spreadReference.style.left = (refStartLeft + dx) + 'px';
    spreadReference.style.top = (refStartTop + dy) + 'px';
});

document.addEventListener('mouseup', () => {
    isRefDragging = false;
});

spreadRefClose.addEventListener('click', hideSpreadReference);

function clearSpreadSlots() {
    spreadSlots.forEach(s => s.element.remove());
    spreadSlots = [];
}

function updateSpreadSlotsFilled() {
    spreadSlots.forEach(slot => {
        const pos = slot.position;
        if (isSlotFilledByCard(pos)) {
            slot.element.classList.add('filled');
        } else {
            slot.element.classList.remove('filled');
        }
    });
    
    // Update reference panel
    updateSpreadReference();
}

function findNearestSlot(percentX, percentY, threshold = 10) {
    if (!currentSpread || spreadSlots.length === 0) return null;
    
    let nearest = null;
    let minDist = threshold;
    
    spreadSlots.forEach(slot => {
        const pos = slot.position;
        const dist = Math.sqrt(
            Math.pow(percentX - pos.percentX, 2) + 
            Math.pow(percentY - pos.percentY, 2)
        );
        
        if (dist < minDist && !isSlotFilledByCard(pos)) {
            minDist = dist;
            nearest = slot;
        }
    });
    
    return nearest;
}

function highlightNearestSlot(percentX, percentY) {
    // Remove all highlights
    spreadSlots.forEach(s => s.element.classList.remove('highlight'));
    
    const nearest = findNearestSlot(percentX, percentY);
    if (nearest) {
        nearest.element.classList.add('highlight');
    }
}

function clearSlotHighlights() {
    spreadSlots.forEach(s => s.element.classList.remove('highlight'));
}

// Event listeners
spreadBtn.addEventListener('click', openSpreadPanel);
spreadPanelClose.addEventListener('click', closeSpreadPanel);
spreadOverlay.addEventListener('click', closeSpreadPanel);
clearSpreadBtn.addEventListener('click', clearSpread);

spreadList.addEventListener('click', e => {
    const item = e.target.closest('.spread-item');
    if (item) {
        selectSpread(item.dataset.spreadId);
    }
});

// Handle window resize for spread slots
window.addEventListener('resize', () => {
    if (currentSpread) {
        renderSpreadSlots();
    }
});

// ============================================
// INIT
// ============================================

function init() {
    // Load user preferences (theme, reversals, dev mode)
    loadPreferences();
    
    // Check for saved reading to restore
    const savedReading = loadCurrentReading();
    if (savedReading) {
        restoreReading(savedReading);
    } else {
        initializeDeck();
    }
}

// ============================================
// SAVE MODAL
// ============================================

const saveExistingInfo = document.getElementById('saveExistingInfo');
const saveExistingTitle = document.getElementById('saveExistingTitle');
const saveExistingDate = document.getElementById('saveExistingDate');
const saveNewBtn = document.getElementById('saveNewBtn');

function openSaveModal() {
    if (placedCards.length === 0 && textBoxes.length === 0) {
        alert('No cards or notes to save. Place some cards first!');
        return;
    }
    
    // Check if this reading already exists in history
    const history = getReadingHistory();
    const existingReading = currentReadingId ? history.find(r => r.id === currentReadingId) : null;
    
    if (existingReading) {
        saveModal.classList.add('has-existing');
        saveExistingInfo.classList.add('show');
        saveExistingTitle.textContent = existingReading.title || 'Untitled Reading';
        const date = new Date(existingReading.timestamp);
        saveExistingDate.textContent = `Last saved: ${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
        readingTitleInput.value = existingReading.title || '';
        readingTitleInput.placeholder = 'Update title (optional)';
    } else {
        saveModal.classList.remove('has-existing');
        saveExistingInfo.classList.remove('show');
        readingTitleInput.value = '';
        readingTitleInput.placeholder = 'Enter a title (optional)';
    }
    
    saveModal.classList.add('active');
    readingTitleInput.focus();
}

function closeSaveModal() {
    saveModal.classList.remove('active');
    saveModal.classList.remove('has-existing');
    saveExistingInfo.classList.remove('show');
}

function confirmSave(asNew = false) {
    const title = readingTitleInput.value.trim();
    
    if (asNew) {
        // Generate new ID for "Save as New"
        currentReadingId = generateReadingId();
    }
    
    const id = saveToHistory(title);
    if (id) {
        closeSaveModal();
        showToast(asNew ? 'Saved as new reading!' : 'Reading saved!');
    }
}

saveBtn.addEventListener('click', openSaveModal);
saveCancelBtn.addEventListener('click', closeSaveModal);
saveConfirmBtn.addEventListener('click', () => confirmSave(false));
saveNewBtn.addEventListener('click', () => confirmSave(true));
saveModal.addEventListener('click', e => { if (e.target === saveModal) closeSaveModal(); });
readingTitleInput.addEventListener('keydown', e => { if (e.key === 'Enter') confirmSave(false); });

// ============================================
// HISTORY PANEL
// ============================================

function openHistoryPanel() {
    renderHistoryList();
    historyPanel.classList.add('active');
    historyOverlay.classList.add('active');
}

function closeHistoryPanel() {
    historyPanel.classList.remove('active');
    historyOverlay.classList.remove('active');
}

function renderHistoryList() {
    const history = getReadingHistory();
    
    if (history.length === 0) {
        historyList.innerHTML = '';
        historyEmpty.classList.remove('hidden');
        return;
    }
    
    historyEmpty.classList.add('hidden');
    
    historyList.innerHTML = history.map(reading => {
        const date = new Date(reading.timestamp);
        const dateStr = date.toLocaleDateString();
        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const cardCount = reading.cards.length;
        
        // Show mini card previews (up to 5)
        const cardPreviews = reading.cards.slice(0, 5).map(c => {
            const cardData = TAROT_DECK.find(card => card.id === c.cardId);
            const reversedClass = c.isReversed ? 'reversed' : '';
            if (USE_IMAGES && cardData) {
                const imgUrl = getCardImageUrl(cardData);
                return `<div class="history-item-card ${reversedClass}"><img src="${imgUrl}" alt=""></div>`;
            }
            return `<div class="history-item-card ${reversedClass}">${getDisplayNumber(cardData)}</div>`;
        }).join('');
        
        const moreCards = cardCount > 5 ? `<div class="history-item-card">+${cardCount - 5}</div>` : '';
        
        return `
            <div class="history-item" data-reading-id="${reading.id}">
                <div class="history-item-title">${reading.title || 'Untitled Reading'}</div>
                <div class="history-item-meta">
                    <span>${dateStr} ${timeStr} · ${cardCount} card${cardCount !== 1 ? 's' : ''}</span>
                    <button class="history-item-delete" data-delete-id="${reading.id}" title="Delete">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                    </button>
                </div>
                <div class="history-item-cards">${cardPreviews}${moreCards}</div>
            </div>
        `;
    }).join('');
}

function loadReadingFromHistory(readingId) {
    const history = getReadingHistory();
    const reading = history.find(r => r.id === readingId);
    if (reading) {
        restoreReading(reading);
        closeHistoryPanel();
        showToast('Reading restored!');
    }
}

function deleteReadingFromHistory(readingId, e) {
    e.stopPropagation();
    if (confirm('Delete this reading?')) {
        deleteFromHistory(readingId);
        renderHistoryList();
    }
}

function clearAllHistory() {
    if (confirm('Delete all reading history? This cannot be undone.')) {
        localStorage.removeItem(STORAGE_KEYS.READING_HISTORY);
        renderHistoryList();
        showToast('History cleared');
    }
}

historyBtn.addEventListener('click', openHistoryPanel);
historyClose.addEventListener('click', closeHistoryPanel);
historyOverlay.addEventListener('click', closeHistoryPanel);
clearHistoryBtn.addEventListener('click', clearAllHistory);

historyList.addEventListener('click', e => {
    const deleteBtn = e.target.closest('.history-item-delete');
    if (deleteBtn) {
        deleteReadingFromHistory(deleteBtn.dataset.deleteId, e);
        return;
    }
    
    const item = e.target.closest('.history-item');
    if (item) {
        loadReadingFromHistory(item.dataset.readingId);
    }
});

// ============================================
// TOAST NOTIFICATION
// ============================================

function showToast(message, duration = 2000) {
    // Remove existing toast
    const existing = document.querySelector('.toast');
    if (existing) existing.remove();
    
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    // Trigger animation
    requestAnimationFrame(() => toast.classList.add('show'));
    
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

init();
</script></body></html>
